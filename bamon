#!/usr/bin/env bash
# This script was generated by bashly 1.3.2 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
bamon_usage() {
  printf "bamon - Bash Daemon Monitor - A tool for monitoring and executing bash scripts\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon [OPTIONS] COMMAND\n"
  printf "  bamon [COMMAND] --help\n"
  printf "  bamon --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Display current status of all configured scripts\n" "status     "
  printf "  %s   Add a new script to monitor\n" "add        "
  printf "  %s   Remove a script from monitoring\n" "remove     "
  printf "  %s   Execute all enabled scripts immediately\n" "now        "
  printf "  %s   Start the daemon process\n" "start      "
  printf "  %s   Stop the daemon process\n" "stop       "
  printf "  %s   Restart the daemon process\n" "restart    "
  printf "  %s   List all configured scripts\n" "list       "
  printf "  %s   Show system performance metrics and optimization status\n" "performance"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Global Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--version, -V"
    printf "    Show version information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--help, -h"
    printf "    Show help information\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
bamon_status_usage() {
  printf "bamon status - Display current status of all configured scripts\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon status [OPTIONS]\n"
  printf "  bamon status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Show detailed information including full output\n"
    echo

    # :flag.usage
    printf "  %s\n" "--failed-only, -f"
    printf "    Show only failed scripts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--json, -j"
    printf "    Output in JSON format\n"
    echo

    # :flag.usage
    printf "  %s\n" "--name, -n SCRIPT_NAME"
    printf "    Check status of a specific script\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bamon status\n"
    printf "  bamon status --verbose\n"
    printf "  bamon status --failed-only\n"
    printf "  bamon status --json\n"
    printf "  bamon status --name health_check\n"
    echo

  fi
}

# :command.usage
bamon_add_usage() {
  printf "bamon add - Add a new script to monitor\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon add NAME [OPTIONS]\n"
  printf "  bamon add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--command, -c COMMAND (required)"
    printf "    Bash command/code to execute\n"
    echo

    # :flag.usage
    printf "  %s\n" "--interval, -i SECONDS"
    printf "    Execution interval in seconds - default 60\n"
    echo

    # :flag.usage
    printf "  %s\n" "--description, -d TEXT"
    printf "    Description of what the script does\n"
    echo

    # :flag.usage
    printf "  %s\n" "--enabled"
    printf "    Set script as enabled - default\n"
    echo

    # :flag.usage
    printf "  %s\n" "--disabled"
    printf "    Set script as disabled\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Script name/ID\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bamon add health_check --command 'curl -s -o /dev/null -w %%{http_code}\n  https://google.com' --interval 30\n"
    printf "  bamon add disk_check --command 'df -h / | awk NR==2' --description 'Check disk\n  usage'\n"
    echo

  fi
}

# :command.usage
bamon_remove_usage() {
  printf "bamon remove - Remove a script from monitoring\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon remove NAME [OPTIONS]\n"
  printf "  bamon remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Remove without confirmation\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Script name/ID to remove\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bamon remove health_check\n"
    printf "  bamon remove old_script --force\n"
    echo

  fi
}

# :command.usage
bamon_now_usage() {
  printf "bamon now - Execute all enabled scripts immediately\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon now [OPTIONS]\n"
  printf "  bamon now --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--name, -n SCRIPT_NAME"
    printf "    Execute only specific script by name\n"
    echo

    # :flag.usage
    printf "  %s\n" "--async, -a"
    printf "    Execute scripts asynchronously - default sequential\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bamon now\n"
    printf "  bamon now --name health_check\n"
    printf "  bamon now --async\n"
    echo

  fi
}

# :command.usage
bamon_start_usage() {
  printf "bamon start - Start the daemon process\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon start [OPTIONS]\n"
  printf "  bamon start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--daemon, -d"
    printf "    Run in background (daemon mode)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--config, -c CONFIG_FILE"
    printf "    Specify custom config file path\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bamon start\n"
    printf "  bamon start --daemon\n"
    printf "  bamon start --config /etc/bamon/config.yml\n"
    echo

  fi
}

# :command.usage
bamon_stop_usage() {
  printf "bamon stop - Stop the daemon process\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon stop [OPTIONS]\n"
  printf "  bamon stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force kill the daemon\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bamon stop\n"
    printf "  bamon stop --force\n"
    echo

  fi
}

# :command.usage
bamon_restart_usage() {
  printf "bamon restart - Restart the daemon process\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon restart [OPTIONS]\n"
  printf "  bamon restart --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--daemon, -d"
    printf "    Run in background (daemon mode)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--config, -c CONFIG_FILE"
    printf "    Specify custom config file path\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bamon restart\n"
    printf "  bamon restart --daemon\n"
    echo

  fi
}

# :command.usage
bamon_list_usage() {
  printf "bamon list - List all configured scripts\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon list [OPTIONS]\n"
  printf "  bamon list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--enabled-only, -e"
    printf "    Show only enabled scripts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--disabled-only, -d"
    printf "    Show only disabled scripts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bamon list\n"
    printf "  bamon list --enabled-only\n"
    printf "  bamon list --disabled-only\n"
    echo

  fi
}

# :command.usage
bamon_performance_usage() {
  printf "bamon performance - Show system performance metrics and optimization status\n\n"

  printf "%s\n" "Usage:"
  printf "  bamon performance [OPTIONS]\n"
  printf "  bamon performance --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Show detailed performance information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--format, -f FORMAT"
    printf "    Output format: table, json (default: table)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--json"
    printf "    Output in JSON format\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bamon performance\n"
    printf "  bamon performance --verbose\n"
    printf "  bamon performance --json\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/config.sh
#!/usr/bin/env bash
# Configuration management functions for bamon

# Default configuration file location
CONFIG_FILE="${BAMON_CONFIG_FILE:-${HOME}/.config/bamon/config.yaml}"
LOG_DIR="${HOME}/.local/share/bamon/logs"
PID_DIR="${HOME}/.local/share/bamon"

# Create default configuration
function init_config() {
  # Ensure CONFIG_FILE is set
  CONFIG_FILE="${CONFIG_FILE:-${BAMON_CONFIG_FILE:-${HOME}/.config/bamon/config.yaml}}"
  local config_dir="$(dirname "${CONFIG_FILE}")"

  # Create directories if they don't exist
  if [[ ! -d "$config_dir" ]]; then
    mkdir -p "$config_dir"
  fi

  if [[ ! -d "$LOG_DIR" ]]; then
    mkdir -p "$LOG_DIR"
  fi

  if [[ ! -d "$PID_DIR" ]]; then
    mkdir -p "$PID_DIR"
  fi

  # Create default config if it doesn't exist
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    cat > "${CONFIG_FILE}" << EOF
daemon:
  default_interval: 60
  log_file: "${LOG_DIR}/bamon.log"
  pid_file: "${PID_DIR}/bamon.pid"
  max_concurrent: 10

sandbox:
  timeout: 30
  max_cpu_time: 60
  max_file_size: 10240
  max_virtual_memory: 102400

performance:
  enable_monitoring: true
  load_threshold: 0.8
  cache_ttl: 30
  optimize_scheduling: true

scripts: []
EOF
    echo "Created default configuration at ${CONFIG_FILE}"
  fi
}

# Load configuration from file
function load_config() {
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    init_config
  fi

  # Check if yq is available for YAML parsing
  if command -v yq >/dev/null 2>&1; then
    return 0
  else
    echo "Warning: yq not found. YAML parsing will be limited." >&2
    return 1
  fi
}

# Get a configuration value using yq
function get_config_value() {
  local key="$1"
  local default_value="${2:-}"

  if command -v yq >/dev/null 2>&1; then
    local result=$(yq eval ".${key}" "${CONFIG_FILE}" 2>/dev/null)
    if [[ "$result" == "null" || -z "$result" ]]; then
      echo "$default_value"
    else
      echo "$result"
    fi
  else
    echo "$default_value"
  fi
}

# Set a configuration value using yq
function set_config_value() {
  local key="$1"
  local value="$2"

  if command -v yq >/dev/null 2>&1; then
    yq eval ".${key} = \"${value}\"" -i "${CONFIG_FILE}"
  else
    echo "Error: yq not available for configuration updates" >&2
    return 1
  fi
}

# Add a script to configuration
function add_script() {
  local name="$1"
  local command="$2"
  local interval="${3:-60}"
  local description="${4:-}"
  local enabled="${5:-true}"

  # Check if script already exists
  if script_exists "$name"; then
    echo "Error: Script '$name' already exists" >&2
    return 1
  fi

  if command -v yq >/dev/null 2>&1; then
    # Add script to the scripts array
    yq eval ".scripts += [{\"name\": \"${name}\", \"command\": \"${command}\", \"interval\": ${interval}, \"description\": \"${description}\", \"enabled\": ${enabled}}]" -i "${CONFIG_FILE}"
    echo "Added script '$name' to configuration"
  else
    echo "Error: yq not available for adding scripts" >&2
    return 1
  fi
}

# Remove a script from configuration
function remove_script() {
  local name="$1"

  if command -v yq >/dev/null 2>&1; then
    # Remove script from the scripts array
    yq eval "del(.scripts[] | select(.name == \"${name}\"))" -i "${CONFIG_FILE}"
    echo "Removed script '$name' from configuration"
  else
    echo "Error: yq not available for removing scripts" >&2
    return 1
  fi
}

# Check if a script exists
function script_exists() {
  local name="$1"

  if command -v yq >/dev/null 2>&1; then
    local count=$(yq eval ".scripts[] | select(.name == \"${name}\") | length" "${CONFIG_FILE}" 2>/dev/null)
    [[ "$count" -gt 0 ]]
  else
    return 1
  fi
}

# Get all scripts
function get_all_scripts() {
  if command -v yq >/dev/null 2>&1; then
    yq eval '.scripts[]' "${CONFIG_FILE}" 2>/dev/null
  else
    echo "[]"
  fi
}

# Get script by name
function get_script() {
  local name="$1"

  if command -v yq >/dev/null 2>&1; then
    yq eval ".scripts[] | select(.name == \"${name}\")" "${CONFIG_FILE}" 2>/dev/null
  else
    echo "{}"
  fi
}

# Update script property
function update_script_property() {
  local name="$1"
  local property="$2"
  local value="$3"

  if command -v yq >/dev/null 2>&1; then
    yq eval "(.scripts[] | select(.name == \"${name}\") | .${property}) = \"${value}\"" -i "${CONFIG_FILE}"
  else
    echo "Error: yq not available for updating scripts" >&2
    return 1
  fi
}

# Validate configuration file
function validate_config() {
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    echo "Error: Configuration file not found: ${CONFIG_FILE}" >&2
    return 1
  fi

  if command -v yq >/dev/null 2>&1; then
    # Check if it's valid YAML
    if ! yq eval '.' "${CONFIG_FILE}" >/dev/null 2>&1; then
      echo "Error: Invalid YAML in configuration file" >&2
      return 1
    fi

    # Check required fields
    local daemon_config=$(yq eval '.daemon' "${CONFIG_FILE}" 2>/dev/null)
    if [[ -z "$daemon_config" || "$daemon_config" == "null" ]]; then
      echo "Error: Missing daemon configuration" >&2
      return 1
    fi

    local scripts_config=$(yq eval '.scripts' "${CONFIG_FILE}" 2>/dev/null)
    if [[ -z "$scripts_config" || "$scripts_config" == "null" ]]; then
      echo "Error: Missing scripts configuration" >&2
      return 1
    fi

    echo "Configuration file is valid"
    return 0
  else
    echo "Warning: Cannot validate YAML without yq" >&2
    return 1
  fi
}

# Get daemon configuration
function get_daemon_config() {
  if command -v yq >/dev/null 2>&1; then
    yq eval '.daemon' "${CONFIG_FILE}" 2>/dev/null
  else
    echo "{}"
  fi
}

# Get log file path
function get_log_file() {
  get_config_value "daemon.log_file" "${LOG_DIR}/bamon.log"
}

# Get PID file path
function get_pid_file() {
  get_config_value "daemon.pid_file" "${PID_DIR}/bamon.pid"
}

# Get default interval
function get_default_interval() {
  get_config_value "daemon.default_interval" "60"
}

# Get max concurrent executions
function get_max_concurrent() {
  get_config_value "daemon.max_concurrent" "10"
}

# Get sandbox timeout
function get_sandbox_timeout() {
  get_config_value "sandbox.timeout" "30"
}

# Get sandbox max CPU time
function get_sandbox_max_cpu_time() {
  get_config_value "sandbox.max_cpu_time" "60"
}

# Get sandbox max file size
function get_sandbox_max_file_size() {
  get_config_value "sandbox.max_file_size" "10240"
}

# Get sandbox max virtual memory
function get_sandbox_max_virtual_memory() {
  get_config_value "sandbox.max_virtual_memory" "102400"
}

# Performance configuration functions
function get_performance_config() {
  local key="$1"
  local default="$2"
  get_config_value "performance.$key" "$default"
}

function is_performance_monitoring_enabled() {
  get_performance_config "enable_monitoring" "true"
}

function get_performance_load_threshold() {
  get_performance_config "load_threshold" "0.8"
}

function get_performance_cache_ttl() {
  get_performance_config "cache_ttl" "30"
}

function is_performance_scheduling_optimized() {
  get_performance_config "optimize_scheduling" "true"
}

# src/lib/execution.sh
#!/usr/bin/env bash
# Script execution functions for bamon

# Libraries are included via bashly custom_includes

# Default timeout for script execution (seconds)
DEFAULT_TIMEOUT=30

# Generate specific error messages based on exit code and content
function generate_error_message() {
  local script_name="$1"
  local exit_code="$2"
  local output="$3"
  local duration="$4"

  # Check for timeout (exit code 124 is typically used for timeout)
  if [[ "$exit_code" == "124" ]]; then
    local timeout_seconds=$(get_script_timeout "$script_name")
    echo "Timeout after ${timeout_seconds}s"
    return
  fi

  # Check if output contains timeout message
  if [[ "$output" == *"timed out"* ]] || [[ "$output" == *"timeout"* ]]; then
    local timeout_seconds=$(get_script_timeout "$script_name")
    echo "Timeout after ${timeout_seconds}s"
    return
  fi

  # Check for memory issues
  if [[ "$output" == *"memory"* ]] || [[ "$output" == *"Memory"* ]]; then
    echo "Memory error"
    return
  fi

  # Check for permission issues
  if [[ "$output" == *"Permission denied"* ]] || [[ "$output" == *"permission"* ]]; then
    echo "Permission denied"
    return
  fi

  # Check for file not found
  if [[ "$output" == *"No such file"* ]] || [[ "$output" == *"not found"* ]]; then
    echo "File not found"
    return
  fi

  # Check for network issues
  if [[ "$output" == *"Connection refused"* ]] || [[ "$output" == *"network"* ]]; then
    echo "Network error"
    return
  fi

  # For custom failing scripts, show the actual output
  if [[ "$script_name" == "failing_test" ]]; then
    echo "$output"
    return
  fi

  # Default: show generic error with exit code
  echo "Failed (exit code: $exit_code)"
}

# Get script timeout from configuration
function get_script_timeout() {
  local script_name="$1"
  local timeout=$(get_config_value "sandbox.timeout" "$DEFAULT_TIMEOUT")
  echo "$timeout"
}

# Execute a script with sandboxed environment
function execute_script() {
  local script_name="$1"
  local script_command="$2"
  local timeout="${3:-$DEFAULT_TIMEOUT}"
  local max_memory_mb="${4:-100}"

  local start_time=$(date +%s)
  local output=""
  local exit_code=0

  log_info "Executing script '${script_name}': ${script_command}" "$script_name"

  # Check if we can run more scripts (performance optimization)
  if ! can_run_more_scripts; then
    log_warn "Skipping script '$script_name' due to system load or capacity limits"
    return 1
  fi

  # Use sandboxed execution
  local result
  result=$(execute_sandboxed_from_config "$script_name" "$script_command")

  # Parse result (format: "exit_code:output")
  if [[ "$result" =~ ^([0-9]+):(.*)$ ]]; then
    exit_code="${BASH_REMATCH[1]}"
    output="${BASH_REMATCH[2]}"
  else
    log_error "Failed to parse sandbox execution result for '$script_name'"
    exit_code=1
    output="ERROR: Failed to parse execution result"
  fi

  local end_time=$(date +%s)
  local duration=$((end_time - start_time))

  # Track performance metrics
  local success="true"
  local error_msg=""
  if [[ $exit_code -ne 0 ]]; then
    success="false"
    # Generate specific error messages based on exit code and content
    error_msg=$(generate_error_message "$script_name" "$exit_code" "$output" "$duration")
  fi
  track_script_execution "$script_name" "$duration" "$success" "$exit_code" "$output" "$error_msg"

  # Log the result
  log_script_result "$script_name" "$exit_code" "$output" "$duration"

  # Return exit code
  return $exit_code
}

# Execute multiple scripts
function execute_scripts() {
  local script_names=("$@")
  local results=()
  local failed_scripts=()

  for script_name in "${script_names[@]}"; do
    local script_info=$(get_script "$script_name")
    if [[ -z "$script_info" || "$script_info" == "{}" ]]; then
      log_error "Script '$script_name' not found in configuration" "$script_name"
      continue
    fi

    # Extract script details using yq
    local script_command=$(echo "$script_info" | yq eval '.command' - 2>/dev/null)
    local script_interval=$(echo "$script_info" | yq eval '.interval' - 2>/dev/null)
    local script_enabled=$(echo "$script_info" | yq eval '.enabled' - 2>/dev/null)

    if [[ "$script_enabled" != "true" ]]; then
      log_info "Skipping disabled script '$script_name'" "$script_name"
      continue
    fi

    if [[ -z "$script_command" ]]; then
      log_error "No command defined for script '$script_name'" "$script_name"
      continue
    fi

    # Execute the script
    if execute_script "$script_name" "$script_command" "$script_interval"; then
      results+=("$script_name:SUCCESS")
    else
      results+=("$script_name:FAILED")
      failed_scripts+=("$script_name")
    fi
  done

  # Print summary
  echo "Execution Summary:"
  for result in "${results[@]}"; do
    echo "  $result"
  done

  # Return number of failed scripts
  return ${#failed_scripts[@]}
}

# Execute all enabled scripts
function execute_all_scripts() {
  # Cleanup old cache entries
  cleanup_cache

  # Use optimized scheduling if enabled
  local script_names=()
  if is_scheduling_optimized; then
    while IFS= read -r script_name; do
      script_names+=("$script_name")
    done < <(optimize_schedule)
  else
    # Fallback to original method
    local scripts_json=$(get_all_scripts)

    # Extract script names from YAML
    while IFS= read -r line; do
      if [[ "$line" =~ ^name:\ (.+)$ ]]; then
        script_names+=("${BASH_REMATCH[1]}")
      fi
    done <<< "$scripts_json"
  fi

  if [[ ${#script_names[@]} -eq 0 ]]; then
    echo "No scripts configured"
    return 0
  fi

  execute_scripts "${script_names[@]}"
}

# Check if daemon is running
function is_daemon_running() {
  local pid_file=$(get_pid_file)

  # First check PID file
  if [[ -f "$pid_file" ]]; then
    local pid=$(cat "$pid_file" 2>/dev/null)
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
      return 0
    else
      # Clean up stale PID file
      rm -f "$pid_file"
    fi
  fi

  # Fallback: check for running bamon daemon processes (exclude current process)
  local current_pid=$$
  local daemon_pids=$(ps aux | grep -E "bamon start --daemon|daemon_loop" | grep -v grep | awk -v current="$current_pid" '$2 != current {print $2}')
  if [[ -n "$daemon_pids" ]]; then
    # Check if any of the found PIDs are actually running
    for pid in $daemon_pids; do
      if kill -0 "$pid" 2>/dev/null; then
        # Update PID file with the first running daemon PID
        echo "$pid" > "$pid_file"
        return 0
      fi
    done
  fi

  return 1
}

# Start daemon
function start_daemon() {
  local daemon_mode="${1:-false}"

  # Check if daemon is running and get PID before any cleanup
  local pid_file=$(get_pid_file)
  local existing_pid=""
  if [[ -f "$pid_file" ]]; then
    existing_pid=$(cat "$pid_file" 2>/dev/null)
  fi

  if is_daemon_running; then
    echo "Daemon is already running (PID: $existing_pid)"
    return 0
  fi

  log_info "Starting bamon daemon"

  if [[ "$daemon_mode" == "true" ]]; then
    # Start in background with output redirected to single log file
    local log_file=$(get_log_file)

    # Create log directory if it doesn't exist
    mkdir -p "$(dirname "$log_file")"

    # Start daemon in background with both stdout and stderr redirected to single log file

    daemon_loop > "$log_file" 2>&1 &
    local daemon_pid=$!
    echo "$daemon_pid" > "$(get_pid_file)"
    echo "Daemon started in background (PID: $daemon_pid)"
    echo "Logs: $log_file"

  else
    # Start in foreground
    daemon_loop
  fi
}

# Stop daemon
function stop_daemon() {
  local force="${1:-false}"
  local pid_file=$(get_pid_file)

  if ! is_daemon_running; then
    echo "Daemon is not running"
    return 0
  fi

  local pid=$(cat "$pid_file")
  log_info "Stopping daemon (PID: $pid)"

  if [[ "$force" == "true" ]]; then
    kill -9 "$pid" 2>/dev/null
  else
    kill -TERM "$pid" 2>/dev/null
  fi

  # Wait for process to stop
  local count=0
  while kill -0 "$pid" 2>/dev/null && [[ $count -lt 10 ]]; do
    sleep 1
    ((count++))
  done

  if kill -0 "$pid" 2>/dev/null; then
    echo "Warning: Daemon did not stop gracefully, forcing..."
    kill -9 "$pid" 2>/dev/null
  fi

  rm -f "$pid_file"
  echo "Daemon stopped"
}

# Initialize script execution tracking
function init_script_execution_tracking() {
  local tracking_file="$HOME/.config/bamon/script_execution_times.json"

  # Create directory if it doesn't exist
  mkdir -p "$(dirname "$tracking_file")"

  # Initialize empty tracking file if it doesn't exist
  if [[ ! -f "$tracking_file" ]]; then
    echo '{}' > "$tracking_file"
  fi
}

# Execute scripts based on their intervals
function execute_scheduled_scripts() {
  local current_time=$(date +%s)
  local scripts_json=$(get_all_scripts)
  local script_names=()

  # Extract script names and intervals from YAML
  while IFS= read -r line; do
    if [[ "$line" =~ ^name:\ (.+)$ ]]; then
      script_names+=("${BASH_REMATCH[1]}")
    fi
  done <<< "$scripts_json"

  # Check each script's interval
  for script_name in "${script_names[@]}"; do
    if should_execute_script "$script_name" "$current_time"; then
      log_info "Executing scheduled script: $script_name"

      # Get script command from YAML array
      local script_command=$(yq eval ".scripts[] | select(.name == \"$script_name\") | .command" ~/.config/bamon/config.yaml 2>/dev/null)
      if [[ -n "$script_command" ]]; then
        execute_script "$script_name" "$script_command"
        update_script_execution_time "$script_name" "$current_time"
      else
        log_error "No command found for script '$script_name'"
      fi
    fi
  done
}

# Check if a script should be executed based on its interval
function should_execute_script() {
  local script_name="$1"
  local current_time="$2"
  local tracking_file="$HOME/.config/bamon/script_execution_times.json"

  # Get script interval from config
  local interval=$(get_script_interval "$script_name")
  if [[ -z "$interval" || "$interval" -le 0 ]]; then
    return 1
  fi

  # Get last execution time
  local last_execution=$(cat "$tracking_file" 2>/dev/null | jq -r ".\"$script_name\" // 0" 2>/dev/null)
  if [[ "$last_execution" == "null" || -z "$last_execution" ]]; then
    last_execution=0
  fi

  # Check if enough time has passed
  local time_since_last=$((current_time - last_execution))
  if [[ $time_since_last -ge $interval ]]; then
    return 0
  else
    return 1
  fi
}

# Update script execution time
function update_script_execution_time() {
  local script_name="$1"
  local execution_time="$2"
  local tracking_file="$HOME/.config/bamon/script_execution_times.json"

  # Update the tracking file
  local temp_file=$(mktemp)
  cat "$tracking_file" | jq ".\"$script_name\" = $execution_time" > "$temp_file" 2>/dev/null
  mv "$temp_file" "$tracking_file"
}

# Get script interval from config
function get_script_interval() {
  local script_name="$1"
  local scripts_json=$(get_all_scripts)
  local in_script=false
  local current_script=""

  while IFS= read -r line; do
    if [[ "$line" =~ ^name:\ (.+)$ ]]; then
      current_script="${BASH_REMATCH[1]}"
      in_script=true
    elif [[ "$line" =~ ^interval:\ (.+)$ ]] && [[ "$in_script" == "true" ]] && [[ "$current_script" == "$script_name" ]]; then
      echo "${BASH_REMATCH[1]}"
      return 0
    elif [[ "$line" =~ ^name:  ]] && [[ "$in_script" == "true" ]]; then
      in_script=false
    fi
  done <<< "$scripts_json"

  echo "60"  # Default interval
}

# Main daemon loop
function daemon_loop() {
  # Set daemon mode for logging
  export BAMON_DAEMON_MODE=true

  # Initialize performance monitoring
  init_performance_monitoring

  # Initialize script execution tracking
  init_script_execution_tracking

  log_info "Daemon loop started (PID: $$)"

  # Trap signals for graceful shutdown
  trap 'log_info "Received SIGTERM, shutting down gracefully"; exit 0' TERM
  trap 'log_info "Received SIGINT, shutting down gracefully"; exit 0' INT

  while true; do
    # Disable exit on error for daemon loop
    set +e

    # Rotate log if needed
    rotate_log_if_needed

    # Execute scripts based on their intervals
    execute_scheduled_scripts

    # Re-enable exit on error
    set -e

    # Sleep for a short interval before next check
    sleep 5
  done
}

# src/lib/logging.sh
#!/usr/bin/env bash
# Logging functions for bamon

# Libraries are included via bashly custom_includes

# Log levels
LOG_LEVEL_ERROR=0
LOG_LEVEL_WARN=1
LOG_LEVEL_INFO=2
LOG_LEVEL_DEBUG=3

# Default log level
DEFAULT_LOG_LEVEL=$LOG_LEVEL_INFO

# Get current log level
function get_log_level() {
  local level=$(get_config_value "daemon.log_level" "$DEFAULT_LOG_LEVEL")
  echo "${level:-$DEFAULT_LOG_LEVEL}"
}

# Check if we should log at this level
function should_log() {
  local level="$1"
  local current_level=$(get_log_level)

  # Default to INFO level if log level is not set
  if [[ -z "$current_level" || "$current_level" == "null" ]]; then
    current_level=$LOG_LEVEL_INFO
  fi

  if [[ $level -le $current_level ]]; then
    return 0
  else
    return 1
  fi
}

# Format log message
function format_log_message() {
  local level="$1"
  local message="$2"
  local script_name="$3"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

  local level_name
  case $level in
    $LOG_LEVEL_ERROR) level_name="ERROR" ;;
    $LOG_LEVEL_WARN)  level_name="WARN"  ;;
    $LOG_LEVEL_INFO)  level_name="INFO"  ;;
    $LOG_LEVEL_DEBUG) level_name="DEBUG" ;;
    *)                level_name="INFO"  ;;
  esac

  if [[ -n "$script_name" ]]; then
    echo "[$timestamp] [$level_name] [$script_name] $message"
  else
    echo "[$timestamp] [$level_name] [bamon] $message"
  fi
}

# Write to log file
function write_to_log() {
  local message="$1"
  local log_file=$(get_log_file)

  # Ensure log directory exists
  local log_dir=$(dirname "$log_file")
  mkdir -p "$log_dir" 2>/dev/null

  # Write to log file
  echo "$message" >> "$log_file"
}

# Log error message
function log_error() {
  local message="$1"
  local script_name="$2"

  if should_log $LOG_LEVEL_ERROR; then
    local formatted_message=$(format_log_message $LOG_LEVEL_ERROR "$message" "$script_name")
    echo "$formatted_message" >&2
    write_to_log "$formatted_message"
  fi
}

# Log warning message
function log_warn() {
  local message="$1"
  local script_name="$2"

  if should_log $LOG_LEVEL_WARN; then
    local formatted_message=$(format_log_message $LOG_LEVEL_WARN "$message" "$script_name")
    echo "$formatted_message" >&2
    write_to_log "$formatted_message"
  fi
}

# Log info message
function log_info() {
  local message="$1"
  local script_name="$2"

  if should_log $LOG_LEVEL_INFO; then
    local formatted_message=$(format_log_message $LOG_LEVEL_INFO "$message" "$script_name")
    echo "$formatted_message"
    write_to_log "$formatted_message"
  fi
}

# Log debug message
function log_debug() {
  local message="$1"
  local script_name="$2"

  if should_log $LOG_LEVEL_DEBUG; then
    local formatted_message=$(format_log_message $LOG_LEVEL_DEBUG "$message" "$script_name")
    echo "$formatted_message" >&2
    write_to_log "$formatted_message"
  fi
}

# Log script execution result
function log_script_result() {
  local script_name="$1"
  local exit_code="$2"
  local output="$3"
  local duration="$4"

  if [[ $exit_code -eq 0 ]]; then
    log_info "Script '$script_name' completed successfully in ${duration}s" "$script_name"
  else
    log_error "Script '$script_name' failed with exit code $exit_code in ${duration}s" "$script_name"
  fi

  # Log output if it's not empty and not just whitespace
  if [[ -n "$output" && "$output" =~ [^[:space:]] ]]; then
    log_info "Script '$script_name' output: $output" "$script_name"
  fi
}

# Rotate log file if needed
function rotate_log_if_needed() {
  local log_file=$(get_log_file)
  local max_size=$(get_config_value "daemon.max_log_size" "10485760")  # 10MB default

  if [[ -f "$log_file" ]]; then
    local file_size=$(stat -f%z "$log_file" 2>/dev/null || echo "0")
    if [[ $file_size -gt $max_size ]]; then
      # Rotate log file
      local backup_file="${log_file}.1"
      if [[ -f "$backup_file" ]]; then
        rm -f "$backup_file"
      fi
      mv "$log_file" "$backup_file"
      log_info "Log file rotated due to size limit"
    fi
  fi
}

# src/lib/performance.sh
#!/usr/bin/env bash
# Performance Optimization Library for BAMON
# Provides system load monitoring, resource management, and execution optimization
# Requires Bash 4.0+ for associative array support

# Libraries are included via bashly custom_includes

# Performance monitoring variables using associative arrays (Bash 4.0+ feature)
declare -A PERFORMANCE_CACHE
declare -A PERFORMANCE_CACHE_TIMES
declare -A SCRIPT_EXECUTION_TIMES
declare -A SCRIPT_FAILURE_COUNTS
declare -A SCRIPT_LAST_STATUS
declare -A SCRIPT_LAST_ERROR
declare -A SCRIPT_LAST_OUTPUT
declare -A SCRIPT_LAST_EXIT_CODE
declare -A SYSTEM_LOAD_VALUES

# Persistent storage file for execution data
PERFORMANCE_DATA_FILE="$HOME/.config/bamon/performance_data.json"

# Cache TTL (Time To Live) in seconds
CACHE_TTL=30
LAST_CACHE_UPDATE=0

# Cache statistics tracking
CACHE_HITS=0
CACHE_MISSES=0
CACHE_EVICTIONS=0
CACHE_SIZE=0

# Cache configuration
MAX_CACHE_SIZE=1000

# Performance configuration functions
function get_performance_config() {
  local key="$1"
  local default="$2"
  get_config_value "performance.$key" "$default"
}

# Get enabled scripts function (needed for performance reporting)
function get_enabled_scripts() {
  local scripts_json=$(get_all_scripts)
  local script_names=()

  # Extract script names from YAML
  while IFS= read -r line; do
    if [[ "$line" =~ ^name:\ (.+)$ ]]; then
      script_names+=("${BASH_REMATCH[1]}")
    fi
  done <<< "$scripts_json"

  printf '%s\n' "${script_names[@]}"
}

function is_performance_monitoring_enabled() {
  get_performance_config "enable_monitoring" "true"
}

function get_load_threshold() {
  get_performance_config "load_threshold" "0.8"
}

function get_cache_ttl() {
  get_performance_config "cache_ttl" "30"
}

function is_scheduling_optimized() {
  local result=$(get_performance_config "optimize_scheduling" "true")
  [[ "$result" == "true" ]]
}

# System load monitoring
function get_system_load() {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS: use sysctl - extract first number from { 1.91 2.12 2.01 }
    sysctl -n vm.loadavg | sed 's/{ //' | awk '{print $1}'
  else
    # Linux: use /proc/loadavg
    cat /proc/loadavg | cut -d' ' -f1
  fi
}

function get_cpu_cores() {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    sysctl -n hw.ncpu
  else
    nproc
  fi
}

function is_system_overloaded() {
  if ! is_performance_monitoring_enabled; then
    return 1
  fi

  local load=$(get_system_load)
  local cores=$(get_cpu_cores)
  local threshold=$(get_load_threshold)
  local max_load=$(echo "$cores * $threshold" | bc -l)

  if (( $(echo "$load > $max_load" | bc -l) )); then
    log_warn "System load is high: $load (threshold: $max_load)"
    return 0  # true, system is overloaded
  fi
  return 1  # false, system is not overloaded
}

# Resource monitoring
function get_memory_usage() {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS: use vm_stat
    vm_stat | grep "Pages free" | awk '{print $3}' | sed 's/\.//'
  else
    # Linux: use /proc/meminfo
    free | grep Mem | awk '{print $3/$2 * 100.0}'
  fi
}

function get_disk_usage() {
  df -h / | awk 'NR==2 {print $5}' | sed 's/%//'
}

# Concurrent execution management
function count_running_scripts() {
  local count=0
  local pid_file=$(get_pid_file)

  if [[ -f "$pid_file" ]]; then
    local daemon_pid=$(cat "$pid_file")
    if kill -0 "$daemon_pid" 2>/dev/null; then
      count=$(pgrep -P "$daemon_pid" | wc -l)
    fi
  fi

  echo "$count"
}

function can_run_more_scripts() {
  local max_concurrent=$(get_max_concurrent)
  local running=$(count_running_scripts)

  if [[ $running -ge $max_concurrent ]]; then
    log_debug "At max concurrent capacity: $running/$max_concurrent"
    return 1  # false, at max capacity
  fi

  # Check system load
  if is_system_overloaded; then
    return 1  # false, system is overloaded
  fi

  return 0  # true, can run more scripts
}

# Caching system using associative arrays (Bash 4.0+)
function get_cached_value() {
  local key="$1"
  local current_time=$(date +%s)

  if [[ -n "${PERFORMANCE_CACHE[$key]}" ]]; then
    local cached_time="${PERFORMANCE_CACHE_TIMES[$key]}"
    local age=$((current_time - cached_time))

    if [[ $age -lt $CACHE_TTL ]]; then
      # Cache hit
      CACHE_HITS=$((CACHE_HITS + 1))
      echo "${PERFORMANCE_CACHE[$key]}"
      return 0
    else
      # Cache miss due to TTL expiration
      CACHE_MISSES=$((CACHE_MISSES + 1))
      # Remove expired entry
      unset PERFORMANCE_CACHE[$key]
      unset PERFORMANCE_CACHE_TIMES[$key]
      CACHE_SIZE=$((CACHE_SIZE - 1))
    fi
  else
    # Cache miss - key not found
    CACHE_MISSES=$((CACHE_MISSES + 1))
  fi

  return 1
}

function set_cached_value() {
  local key="$1"
  local value="$2"
  local current_time=$(date +%s)

  # Check if this is a new key (for size tracking)
  local is_new_key=false
  if [[ -z "${PERFORMANCE_CACHE[$key]}" ]]; then
    is_new_key=true
  fi

  PERFORMANCE_CACHE[$key]="$value"
  PERFORMANCE_CACHE_TIMES[$key]="$current_time"

  # Update cache size if it's a new key
  if [[ "$is_new_key" == "true" ]]; then
    CACHE_SIZE=$((CACHE_SIZE + 1))
  fi

  # Enforce cache size limits
  enforce_cache_size_limit
}

# Script execution tracking using associative arrays (Bash 4.0+)
function track_script_execution() {
  local script_name="$1"
  local execution_time="$2"
  local success="$3"
  local exit_code="${4:-0}"
  local output="${5:-}"
  local error_msg="${6:-}"

  # Load existing performance data first
  load_performance_data

  # Update execution time
  SCRIPT_EXECUTION_TIMES[$script_name]="$execution_time"

  # Update last execution status
  SCRIPT_LAST_STATUS[$script_name]="$success"

  # Update last execution details
  SCRIPT_LAST_EXIT_CODE[$script_name]="$exit_code"
  SCRIPT_LAST_OUTPUT[$script_name]="$output"
  SCRIPT_LAST_ERROR[$script_name]="$error_msg"

  # Update failure count if script failed
  if [[ "$success" == "false" ]]; then
    local failures="${SCRIPT_FAILURE_COUNTS[$script_name]:-0}"
    SCRIPT_FAILURE_COUNTS[$script_name]=$((failures + 1))
  fi

  # Save to persistent storage
  save_performance_data
}

# Save performance data to persistent storage
function save_performance_data() {
  local data_file="$PERFORMANCE_DATA_FILE"

  # Create directory if it doesn't exist
  mkdir -p "$(dirname "$data_file")"

  # Create JSON data
  local json_data="{"
  json_data+="\"execution_times\":{"
  local first=true
  for key in "${!SCRIPT_EXECUTION_TIMES[@]}"; do
    if [[ "$first" == "true" ]]; then
      first=false
    else
      json_data+=","
    fi
    json_data+="\"$key\":${SCRIPT_EXECUTION_TIMES[$key]}"
  done
  json_data+="},"

  json_data+="\"failure_counts\":{"
  first=true
  for key in "${!SCRIPT_FAILURE_COUNTS[@]}"; do
    if [[ "$first" == "true" ]]; then
      first=false
    else
      json_data+=","
    fi
    json_data+="\"$key\":${SCRIPT_FAILURE_COUNTS[$key]}"
  done
  json_data+="},"

  json_data+="\"last_status\":{"
  first=true
  for key in "${!SCRIPT_LAST_STATUS[@]}"; do
    if [[ "$first" == "true" ]]; then
      first=false
    else
      json_data+=","
    fi
    json_data+="\"$key\":\"${SCRIPT_LAST_STATUS[$key]}\""
  done
  json_data+="},"

  json_data+="\"last_exit_codes\":{"
  first=true
  for key in "${!SCRIPT_LAST_EXIT_CODE[@]}"; do
    if [[ "$first" == "true" ]]; then
      first=false
    else
      json_data+=","
    fi
    json_data+="\"$key\":${SCRIPT_LAST_EXIT_CODE[$key]}"
  done
  json_data+="},"

  json_data+="\"last_outputs\":{"
  first=true
  for key in "${!SCRIPT_LAST_OUTPUT[@]}"; do
    if [[ "$first" == "true" ]]; then
      first=false
    else
      json_data+=","
    fi
    # Escape quotes in output
    local escaped_output="${SCRIPT_LAST_OUTPUT[$key]//\"/\\\"}"
    json_data+="\"$key\":\"$escaped_output\""
  done
  json_data+="},"

  json_data+="\"last_errors\":{"
  first=true
  for key in "${!SCRIPT_LAST_ERROR[@]}"; do
    if [[ "$first" == "true" ]]; then
      first=false
    else
      json_data+=","
    fi
    # Escape quotes in error message
    local escaped_error="${SCRIPT_LAST_ERROR[$key]//\"/\\\"}"
    json_data+="\"$key\":\"$escaped_error\""
  done
  json_data+="}"
  json_data+="}"

  # Save to file
  echo "$json_data" > "$data_file"
}

# Load performance data from persistent storage
function load_performance_data() {
  local data_file="$PERFORMANCE_DATA_FILE"

  if [[ -f "$data_file" ]]; then
    # Load execution times
    local execution_times=$(cat "$data_file" | jq -r '.execution_times | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)
    if [[ -n "$execution_times" ]]; then
      while IFS='=' read -r key value; do
        SCRIPT_EXECUTION_TIMES["$key"]="$value"
      done <<< "$execution_times"
    fi

    # Load failure counts
    local failure_counts=$(cat "$data_file" | jq -r '.failure_counts | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)
    if [[ -n "$failure_counts" ]]; then
      while IFS='=' read -r key value; do
        SCRIPT_FAILURE_COUNTS["$key"]="$value"
      done <<< "$failure_counts"
    fi

    # Load last status
    local last_status=$(cat "$data_file" | jq -r '.last_status | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)
    if [[ -n "$last_status" ]]; then
      while IFS='=' read -r key value; do
        SCRIPT_LAST_STATUS["$key"]="$value"
      done <<< "$last_status"
    fi

    # Load last exit codes
    local last_exit_codes=$(cat "$data_file" | jq -r '.last_exit_codes | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)
    if [[ -n "$last_exit_codes" ]]; then
      while IFS='=' read -r key value; do
        SCRIPT_LAST_EXIT_CODE["$key"]="$value"
      done <<< "$last_exit_codes"
    fi

    # Load last outputs
    local last_outputs=$(cat "$data_file" | jq -r '.last_outputs | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)
    if [[ -n "$last_outputs" ]]; then
      while IFS='=' read -r key value; do
        SCRIPT_LAST_OUTPUT["$key"]="$value"
      done <<< "$last_outputs"
    fi

    # Load last errors
    local last_errors=$(cat "$data_file" | jq -r '.last_errors | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)
    if [[ -n "$last_errors" ]]; then
      while IFS='=' read -r key value; do
        SCRIPT_LAST_ERROR["$key"]="$value"
      done <<< "$last_errors"
    fi
  fi
}

function get_script_avg_execution_time() {
  local script_name="$1"
  echo "${SCRIPT_EXECUTION_TIMES[$script_name]:-0}"
}

function get_script_failure_count() {
  local script_name="$1"
  echo "${SCRIPT_FAILURE_COUNTS[$script_name]:-0}"
}

function get_script_interval() {
  local script_name="$1"
  local script_info=$(get_script "$script_name")

  if [[ -z "$script_info" || "$script_info" == "{}" ]]; then
    echo "60"  # default interval
    return
  fi

  echo "$script_info" | yq eval '.interval' - 2>/dev/null || echo "60"
}

# Optimized script scheduling
function optimize_schedule() {
  if ! is_scheduling_optimized; then
    get_enabled_scripts
    return
  fi

  # Get all enabled scripts with their intervals and execution times
  local scripts_info=()

  while IFS= read -r script_name; do
    local interval=$(get_script_interval "$script_name")
    local avg_time=$(get_script_avg_execution_time "$script_name")
    local failures=$(get_script_failure_count "$script_name")

    # Calculate priority score (lower is better)
    # Prioritize: shorter intervals, faster execution, fewer failures
    local priority_score=$(echo "$interval + $avg_time - ($failures * 10)" | bc -l)

    scripts_info+=("$priority_score:$script_name")
  done < <(get_enabled_scripts)

  # Sort by priority score and return script names
  printf '%s\n' "${scripts_info[@]}" | sort -n | cut -d: -f2
}

# Performance metrics collection
function collect_performance_metrics() {
  local metrics=()

  metrics+=("load:$(get_system_load)")
  metrics+=("memory:$(get_memory_usage)")
  metrics+=("disk:$(get_disk_usage)")
  metrics+=("running_scripts:$(count_running_scripts)")
  metrics+=("max_concurrent:$(get_max_concurrent)")

  printf '%s\n' "${metrics[@]}"
}

# Performance report
function generate_performance_report() {
  # Load persistent performance data
  load_performance_data

  echo "=== BAMON Performance Report ==="
  echo "Timestamp: $(date)"
  echo ""

  echo "System Metrics:"
  collect_performance_metrics | while IFS=: read -r metric value; do
    echo "  $metric: $value"
  done
  echo ""

  echo "Script Performance:"
  for script_name in $(get_enabled_scripts); do
    local avg_time=$(get_script_avg_execution_time "$script_name")
    local failures=$(get_script_failure_count "$script_name")
    echo "  $script_name: avg_time=${avg_time}s, failures=$failures"
  done
  echo ""

  echo "Cache Status:"
  echo "  Cache TTL: ${CACHE_TTL}s"
  echo "  Cached items: ${#PERFORMANCE_CACHE[@]}"
  echo "  Cache hits: $CACHE_HITS"
  echo "  Cache misses: $CACHE_MISSES"
  echo "  Cache evictions: $CACHE_EVICTIONS"
  echo "  Hit rate: $(get_cache_hit_rate)%"
}

# Cache statistics functions
function get_cache_hit_rate() {
  local total_requests=$((CACHE_HITS + CACHE_MISSES))
  if [[ $total_requests -eq 0 ]]; then
    echo "0"
    return
  fi

  local hit_rate=$(echo "scale=2; $CACHE_HITS * 100 / $total_requests" | bc -l)
  echo "$hit_rate"
}

function get_cache_stats() {
  echo "Cache Statistics:"
  echo "  Hits: $CACHE_HITS"
  echo "  Misses: $CACHE_MISSES"
  echo "  Evictions: $CACHE_EVICTIONS"
  echo "  Current size: ${#PERFORMANCE_CACHE[@]}"
  echo "  Hit rate: $(get_cache_hit_rate)%"
}

function reset_cache_stats() {
  CACHE_HITS=0
  CACHE_MISSES=0
  CACHE_EVICTIONS=0
  CACHE_SIZE=0
}

function enforce_cache_size_limit() {
  local current_size=${#PERFORMANCE_CACHE[@]}

  if [[ $current_size -gt $MAX_CACHE_SIZE ]]; then
    # Remove oldest entries (LRU eviction)
    local entries_to_remove=$((current_size - MAX_CACHE_SIZE))
    local evicted_count=0

    # Sort by timestamp and remove oldest entries
    for key in "${!PERFORMANCE_CACHE_TIMES[@]}"; do
      if [[ $evicted_count -ge $entries_to_remove ]]; then
        break
      fi

      unset PERFORMANCE_CACHE[$key]
      unset PERFORMANCE_CACHE_TIMES[$key]
      evicted_count=$((evicted_count + 1))
    done

    # Update statistics
    CACHE_EVICTIONS=$((CACHE_EVICTIONS + evicted_count))
    CACHE_SIZE=$((CACHE_SIZE - evicted_count))

    log_debug "Cache size limit enforced: evicted $evicted_count entries"
  fi
}

# Cleanup old cache entries using associative arrays (Bash 4.0+)
function cleanup_cache() {
  local current_time=$(date +%s)
  local evicted_count=0

  for key in "${!PERFORMANCE_CACHE[@]}"; do
    local cached_time="${PERFORMANCE_CACHE_TIMES[$key]}"
    local age=$((current_time - cached_time))

    if [[ $age -gt $CACHE_TTL ]]; then
      unset PERFORMANCE_CACHE[$key]
      unset PERFORMANCE_CACHE_TIMES[$key]
      evicted_count=$((evicted_count + 1))
    fi
  done

  # Update statistics
  CACHE_EVICTIONS=$((CACHE_EVICTIONS + evicted_count))
  CACHE_SIZE=$((CACHE_SIZE - evicted_count))

  # Ensure cache size doesn't go negative
  if [[ $CACHE_SIZE -lt 0 ]]; then
    CACHE_SIZE=0
  fi
}

# Initialize performance monitoring
function init_performance_monitoring() {
  if is_performance_monitoring_enabled; then
    log_info "Performance monitoring enabled"
    CACHE_TTL=$(get_cache_ttl)
  else
    log_info "Performance monitoring disabled"
  fi
}

# src/lib/sandbox.sh
#!/usr/bin/env bash
# Sandboxing functions for script execution

# Libraries are included via bashly custom_includes

# Default sandbox configuration
DEFAULT_TIMEOUT=30
DEFAULT_MAX_CPU_TIME=60
DEFAULT_MAX_FILE_SIZE=10240
DEFAULT_MAX_VIRTUAL_MEMORY=102400

# Execute script in a sandboxed environment
function execute_sandboxed() {
  local script_name="$1"
  local command="$2"
  local timeout="${3:-$DEFAULT_TIMEOUT}"

  if [[ -z "$script_name" || -z "$command" ]]; then
    log_error "execute_sandboxed: script_name and command are required"
    return 1
  fi

  log_debug "Executing '$script_name' in sandbox with ${timeout}s timeout"

  # Create temporary directory for script
  local temp_dir
  temp_dir=$(mktemp -d)
  if [[ $? -ne 0 ]]; then
    log_error "Failed to create temporary directory for script '$script_name'"
    return 1
  fi

  local temp_script="${temp_dir}/script.sh"

  # Write command to temporary script
  cat > "$temp_script" << EOF
#!/usr/bin/env bash
set -e
# Preserve environment variables
export PATH="\$PATH"
# Use full path to common commands
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/homebrew/bin:\$PATH"
# Execute the command using bash directly
$command
EOF

  chmod +x "$temp_script"

  # Execute with resource limits
  local output
  local exit_code

  # Use timeout and ulimit to restrict resources
  # Note: ulimit settings are inherited by child processes
  output=$(
    (
      ulimit -t "$DEFAULT_MAX_CPU_TIME"  # CPU time limit
      ulimit -f "$DEFAULT_MAX_FILE_SIZE"  # File size limit
      # Skip virtual memory limit on macOS as it's not supported
      if [[ "$OSTYPE" != "darwin"* ]]; then
        ulimit -v "$DEFAULT_MAX_VIRTUAL_MEMORY"  # Virtual memory limit
      fi
      # Use gtimeout on macOS (from GNU coreutils), timeout on Linux
      if [[ "$OSTYPE" == "darwin"* ]]; then
        gtimeout "${timeout}s" "$temp_script" 2>&1
      else
        timeout "${timeout}s" "$temp_script" 2>&1
      fi
    )
  )
  exit_code=$?

  # Clean up temporary files
  rm -rf "$temp_dir"

  # Handle timeout specifically
  if [[ $exit_code -eq 124 ]]; then
    log_error "Script '$script_name' timed out after ${timeout}s"
    output="ERROR: Script execution timed out after ${timeout} seconds"
    exit_code=124
  elif [[ $exit_code -eq 125 ]]; then
    log_error "Script '$script_name' timeout command failed"
    output="ERROR: Timeout command failed"
    exit_code=125
  elif [[ $exit_code -eq 126 ]]; then
    log_error "Script '$script_name' command not executable"
    output="ERROR: Command not executable"
    exit_code=126
  elif [[ $exit_code -eq 127 ]]; then
    log_error "Script '$script_name' command not found"
    output="ERROR: Command not found"
    exit_code=127
  elif [[ $exit_code -eq 137 ]]; then
    log_error "Script '$script_name' killed (SIGKILL)"
    output="ERROR: Script killed due to resource limits"
    exit_code=137
  elif [[ $exit_code -gt 128 ]]; then
    log_error "Script '$script_name' terminated with signal $((exit_code - 128))"
    output="ERROR: Script terminated with signal $((exit_code - 128))"
  fi

  # Return results
  echo "$exit_code:$output"
}

# Execute script with custom resource limits
function execute_sandboxed_with_limits() {
  local script_name="$1"
  local command="$2"
  local timeout="${3:-$DEFAULT_TIMEOUT}"
  local max_cpu_time="${4:-$DEFAULT_MAX_CPU_TIME}"
  local max_file_size="${5:-$DEFAULT_MAX_FILE_SIZE}"
  local max_virtual_memory="${6:-$DEFAULT_MAX_VIRTUAL_MEMORY}"

  if [[ -z "$script_name" || -z "$command" ]]; then
    log_error "execute_sandboxed_with_limits: script_name and command are required"
    return 1
  fi

  log_debug "Executing '$script_name' in sandbox with custom limits: timeout=${timeout}s, cpu=${max_cpu_time}s, file=${max_file_size}KB, mem=${max_virtual_memory}KB"

  # Create temporary directory for script
  local temp_dir
  temp_dir=$(mktemp -d)
  if [[ $? -ne 0 ]]; then
    log_error "Failed to create temporary directory for script '$script_name'"
    return 1
  fi

  local temp_script="${temp_dir}/script.sh"

  # Write command to temporary script
  cat > "$temp_script" << EOF
#!/usr/bin/env bash
set -e
# Preserve environment variables
export PATH="\$PATH"
# Use full path to common commands
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/homebrew/bin:\$PATH"
# Execute the command using bash directly
$command
EOF

  chmod +x "$temp_script"

  # Execute with custom resource limits
  local output
  local exit_code

  output=$(
    (
      ulimit -t "$max_cpu_time"
      ulimit -f "$max_file_size"
      # Skip virtual memory limit on macOS as it's not supported
      if [[ "$OSTYPE" != "darwin"* ]]; then
        ulimit -v "$max_virtual_memory"
      fi
      # Use gtimeout on macOS (from GNU coreutils), timeout on Linux
      if [[ "$OSTYPE" == "darwin"* ]]; then
        gtimeout "${timeout}s" "$temp_script" 2>&1
      else
        timeout "${timeout}s" "$temp_script" 2>&1
      fi
    )
  )
  exit_code=$?

  # Clean up temporary files
  rm -rf "$temp_dir"

  # Handle various exit codes
  case $exit_code in
    124)
      log_error "Script '$script_name' timed out after ${timeout}s"
      output="ERROR: Script execution timed out after ${timeout} seconds"
      ;;
    125)
      log_error "Script '$script_name' timeout command failed"
      output="ERROR: Timeout command failed"
      ;;
    126)
      log_error "Script '$script_name' command not executable"
      output="ERROR: Command not executable"
      ;;
    127)
      log_error "Script '$script_name' command not found"
      output="ERROR: Command not found"
      ;;
    137)
      log_error "Script '$script_name' killed (SIGKILL) - likely due to resource limits"
      output="ERROR: Script killed due to resource limits"
      ;;
    [1-9][0-9][0-9])
      log_error "Script '$script_name' terminated with signal $((exit_code - 128))"
      output="ERROR: Script terminated with signal $((exit_code - 128))"
      ;;
  esac

  # Return results
  echo "$exit_code:$output"
}

# Get sandbox configuration from config file
function get_sandbox_config() {
  # Initialize config if not already done
  init_config

  local timeout=$(get_config_value "sandbox.timeout" "$DEFAULT_TIMEOUT")
  local max_cpu_time=$(get_config_value "sandbox.max_cpu_time" "$DEFAULT_MAX_CPU_TIME")
  local max_file_size=$(get_config_value "sandbox.max_file_size" "$DEFAULT_MAX_FILE_SIZE")
  local max_virtual_memory=$(get_config_value "sandbox.max_virtual_memory" "$DEFAULT_MAX_VIRTUAL_MEMORY")

  # Ensure we have valid values
  timeout="${timeout:-$DEFAULT_TIMEOUT}"
  max_cpu_time="${max_cpu_time:-$DEFAULT_MAX_CPU_TIME}"
  max_file_size="${max_file_size:-$DEFAULT_MAX_FILE_SIZE}"
  max_virtual_memory="${max_virtual_memory:-$DEFAULT_MAX_VIRTUAL_MEMORY}"

  echo "$timeout:$max_cpu_time:$max_file_size:$max_virtual_memory"
}

# Execute script with configuration-based sandbox settings
function execute_sandboxed_from_config() {
  local script_name="$1"
  local command="$2"

  if [[ -z "$script_name" || -z "$command" ]]; then
    log_error "execute_sandboxed_from_config: script_name and command are required"
    echo "1:ERROR: script_name and command are required"
    return 1
  fi

  # Get sandbox configuration from config file
  local config
  config=$(get_sandbox_config)
  IFS=':' read -r timeout max_cpu_time max_file_size max_virtual_memory <<< "$config"

  # Use configured timeout and return the result
  execute_sandboxed "$script_name" "$command" "$timeout"
}

# Validate sandbox configuration
function validate_sandbox_config() {
  local config
  config=$(get_sandbox_config)
  IFS=':' read -r timeout max_cpu_time max_file_size max_virtual_memory <<< "$config"

  local errors=()

  # Validate timeout
  if ! [[ "$timeout" =~ ^[0-9]+$ ]] || [[ $timeout -lt 1 ]] || [[ $timeout -gt 3600 ]]; then
    errors+=("Invalid timeout value: $timeout (must be 1-3600 seconds)")
  fi

  # Validate CPU time limit
  if ! [[ "$max_cpu_time" =~ ^[0-9]+$ ]] || [[ $max_cpu_time -lt 1 ]] || [[ $max_cpu_time -gt 7200 ]]; then
    errors+=("Invalid max_cpu_time value: $max_cpu_time (must be 1-7200 seconds)")
  fi

  # Validate file size limit
  if ! [[ "$max_file_size" =~ ^[0-9]+$ ]] || [[ $max_file_size -lt 1 ]] || [[ $max_file_size -gt 1048576 ]]; then
    errors+=("Invalid max_file_size value: $max_file_size (must be 1-1048576 KB)")
  fi

  # Validate virtual memory limit
  if ! [[ "$max_virtual_memory" =~ ^[0-9]+$ ]] || [[ $max_virtual_memory -lt 1 ]] || [[ $max_virtual_memory -gt 1048576 ]]; then
    errors+=("Invalid max_virtual_memory value: $max_virtual_memory (must be 1-1048576 KB)")
  fi

  if [[ ${#errors[@]} -gt 0 ]]; then
    log_error "Sandbox configuration validation failed:"
    for error in "${errors[@]}"; do
      log_error "  - $error"
    done
    return 1
  fi

  log_debug "Sandbox configuration validation passed"
  return 0
}

# :command.command_functions
# :command.function
bamon_status_command() {

  # src/status_command.sh
  #!/usr/bin/env bash
  # Status Check Command for BAMON
  # Displays the current status of all configured scripts without running them

  # Libraries are included via bashly custom_includes

  # Main status check function
  function status_command() {
    local name="${args[--name]:-}"
    local json_output="${args[--json]:-}"
    local failed_only="${args[--failed-only]:-}"
    local verbose="${args[--verbose]:-}"

    # Handle case when args array is not available (direct function call)
    if [[ -z "${args[--name]:-}" && -n "${1:-}" ]]; then
      name="$1"
    fi

    # Load configuration
    if ! load_config; then
      log_error "Failed to load configuration"
      return 1
    fi

    # Get all scripts or specific script
    local scripts=""
    if [[ -n "$name" ]]; then
      if ! script_exists "$name"; then
        echo "Error: Script '$name' does not exist"
        return 1
      fi
      scripts="$name"
    else
      scripts=$(get_all_scripts)
      if [[ -z "$scripts" ]]; then
        echo "No scripts configured. Use 'bamon add' to add scripts."
        return 0
      fi
    fi

    # Print header if not JSON output
    if [[ "$json_output" != "1" ]]; then
      printf "%-20s %-10s %-20s %-10s %-15s %-20s %-20s %s\n" \
        "NAME" "STATUS" "LAST EXECUTION" "EXIT CODE" "DURATION" "TIME SINCE" "NEXT EXECUTION" "OUTPUT"
      printf "%s\n" "$(printf '=%.0s' {1..140})"
    else
      echo "{"
      echo "  \"scripts\": ["
    fi

    local first=true
    for script in $scripts; do
      # Get script details
      local enabled=$(is_script_enabled "$script")
      local last_run=$(get_script_last_execution_time "$script")
      local last_status=$(get_script_last_status "$script")
      local last_duration=$(get_script_last_duration "$script")
      local last_error=$(get_script_last_error "$script")
      local last_output=$(get_script_last_output "$script")
      local interval=$(get_script_interval "$script")

      # Skip if failed_only is set and script didn't fail
      if [[ "$failed_only" == "true" && "$last_status" != "FAILED" ]]; then
        continue
      fi

      # Calculate time since last execution
      local time_since="Never"
      if [[ -n "$last_run" && "$last_run" != "0" ]]; then
        time_since=$(calculate_time_since "$last_run")
      fi

      # Calculate next execution time
      local next_execution="Not scheduled"
      if [[ "$enabled" == "true" && -n "$last_run" && "$last_run" != "0" && -n "$interval" ]]; then
        next_execution=$(calculate_next_execution "$last_run" "$interval")
      elif [[ "$enabled" != "true" ]]; then
        next_execution="Disabled"
      fi

      # Format result
      local result="Unknown"
      if [[ -n "$last_status" ]]; then
        if [[ "$last_status" == "SUCCESS" ]]; then
          result="Success"
        else
          result="Failed"
        fi
      fi

      # Format duration
      local duration="N/A"
      if [[ -n "$last_duration" && "$last_duration" != "0" ]]; then
        duration=$(format_duration "$last_duration")
      fi

      # Format exit code
      local exit_code="N/A"
      if [[ -n "$last_status" && "$last_status" != "UNKNOWN" ]]; then
        exit_code=$(get_script_exit_code "$script")
      fi

      # Determine output to show based on status
      local output_msg=""
      if [[ "$last_status" == "SUCCESS" ]]; then
        # For successful executions, show stdout
        if [[ -n "$last_output" && "$last_output" != "null" ]]; then
          if [[ ${#last_output} -gt 30 ]]; then
            output_msg="${last_output:0:27}...( more details please run with --json flag )"
          else
            output_msg="$last_output"
          fi
        fi
      else
        # For failed executions, show error message
        if [[ -n "$last_error" && "$last_error" != "null" ]]; then
          if [[ ${#last_error} -gt 30 ]]; then
            output_msg="${last_error:0:27}...( more details please run with --json flag )"
          else
            output_msg="$last_error"
          fi
        fi
      fi

      # Format last execution time
      local last_execution_display="Never"
      if [[ -n "$last_run" && "$last_run" != "0" ]]; then
        last_execution_display=$(format_timestamp "$last_run")
      fi

      # Output in requested format
      if [[ "$json_output" == "1" ]]; then
        if [[ "$first" != "true" ]]; then
          echo "    ,"
        fi
        first=false

        echo "    {"
        echo "      \"name\": \"$script\","
        echo "      \"enabled\": $enabled,"
        echo "      \"lastExecution\": \"$last_execution_display\","
        echo "      \"result\": \"$result\","
        echo "      \"exitCode\": \"$exit_code\","
        echo "      \"duration\": \"$duration\","
        echo "      \"timeSince\": \"$time_since\","
        echo "      \"nextExecution\": \"$next_execution\","
        echo "      \"output\": \"${last_output:-null}\","
        echo "      \"error\": \"${last_error:-null}\""
        echo -n "    }"
      else
        printf "%-20s %-10s %-20s %-10s %-15s %-20s %-20s %s\n" \
          "$script" \
          "$result" \
          "$last_execution_display" \
          "$exit_code" \
          "$duration" \
          "$time_since" \
          "$next_execution" \
          "$output_msg"
      fi
    done

      if [[ "$json_output" == "1" ]]; then
      echo ""
      echo "  ]"
      echo "}"
    fi

    return 0
  }

  # Check if a script exists
  function script_exists() {
    local script_name="$1"
    yq eval ".scripts[] | select(.name == \"$script_name\")" ~/.config/bamon/config.yaml >/dev/null 2>&1
  }

  # Get all enabled scripts
  function get_all_scripts() {
    yq eval '.scripts[] | select(.enabled == true) | .name' ~/.config/bamon/config.yaml 2>/dev/null
  }

  # Check if a script is enabled
  function is_script_enabled() {
    local script_name="$1"
    local enabled=$(yq eval ".scripts[] | select(.name == \"$script_name\") | .enabled" ~/.config/bamon/config.yaml 2>/dev/null)
    if [[ "$enabled" == "true" ]]; then
      echo "true"
    else
      echo "false"
    fi
  }

  # Get script last execution time (timestamp)
  function get_script_last_execution_time() {
    local script_name="$1"
    local tracking_file="$HOME/.config/bamon/script_execution_times.json"

    if [[ -f "$tracking_file" ]]; then
      jq -r ".\"$script_name\" // 0" "$tracking_file" 2>/dev/null || echo "0"
    else
      echo "0"
    fi
  }

  # Get script last status
  function get_script_last_status() {
    local script_name="$1"
    local data_file="$HOME/.config/bamon/performance_data.json"

    if [[ -f "$data_file" ]]; then
      local last_status=$(jq -r ".last_status.\"$script_name\" // \"UNKNOWN\"" "$data_file" 2>/dev/null)
      if [[ "$last_status" == "true" ]]; then
        echo "SUCCESS"
      elif [[ "$last_status" == "false" ]]; then
        echo "FAILED"
      else
        echo "UNKNOWN"
      fi
    else
      echo "UNKNOWN"
    fi
  }

  # Get script last duration
  function get_script_last_duration() {
    local script_name="$1"
    local data_file="$HOME/.config/bamon/performance_data.json"

    if [[ -f "$data_file" ]]; then
      jq -r ".execution_times.\"$script_name\" // 0" "$data_file" 2>/dev/null || echo "0"
    else
      echo "0"
    fi
  }

  # Get script last error (placeholder - would need to be implemented)
  function get_script_last_error() {
    local script_name="$1"
    local data_file="$HOME/.config/bamon/performance_data.json"

    if [[ -f "$data_file" ]]; then
      jq -r ".last_errors.\"$script_name\" // \"\"" "$data_file" 2>/dev/null || echo ""
    else
      echo ""
    fi
  }

  # Get script stdout output
  function get_script_last_output() {
    local script_name="$1"
    local data_file="$HOME/.config/bamon/performance_data.json"

    if [[ -f "$data_file" ]]; then
      jq -r ".last_outputs.\"$script_name\" // \"\"" "$data_file" 2>/dev/null || echo ""
    else
      echo ""
    fi
  }

  # Get script exit code
  function get_script_exit_code() {
    local script_name="$1"
    local data_file="$HOME/.config/bamon/performance_data.json"

    if [[ -f "$data_file" ]]; then
      local exit_code=$(jq -r ".last_exit_codes.\"$script_name\" // \"N/A\"" "$data_file" 2>/dev/null)
      if [[ "$exit_code" == "null" || "$exit_code" == "" ]]; then
        echo "N/A"
      else
        echo "$exit_code"
      fi
    else
      echo "N/A"
    fi
  }

  # Calculate time since last execution
  function calculate_time_since() {
    local last_run_timestamp="$1"
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_run_timestamp))

    if [[ $time_diff -lt 60 ]]; then
      echo "${time_diff}s ago"
    elif [[ $time_diff -lt 3600 ]]; then
      echo "$((time_diff / 60))m ago"
    elif [[ $time_diff -lt 86400 ]]; then
      echo "$((time_diff / 3600))h ago"
    else
      echo "$((time_diff / 86400))d ago"
    fi
  }

  # Calculate next execution time
  function calculate_next_execution() {
    local last_run_timestamp="$1"
    local interval="$2"
    local current_time=$(date +%s)

    # Parse interval (assume it's in seconds for now)
    local next_run_time=$((last_run_timestamp + interval))

    if [[ $next_run_time -lt $current_time ]]; then
      echo "Overdue"
    else
      local time_until=$((next_run_time - current_time))
      if [[ $time_until -lt 60 ]]; then
        echo "In ${time_until}s"
      elif [[ $time_until -lt 3600 ]]; then
        echo "In $((time_until / 60))m"
      elif [[ $time_until -lt 86400 ]]; then
        echo "In $((time_until / 3600))h"
      else
        echo "In $((time_until / 86400))d"
      fi
    fi
  }

  # Format duration in human-readable format
  function format_duration() {
    local duration="$1"

    if [[ $duration -lt 1 ]]; then
      echo "<1s"
    elif [[ $duration -lt 60 ]]; then
      echo "${duration}s"
    elif [[ $duration -lt 3600 ]]; then
      echo "$((duration / 60))m $((duration % 60))s"
    else
      echo "$((duration / 3600))h $((duration / 60 % 60))m"
    fi
  }

  # Format timestamp in human-readable format
  function format_timestamp() {
    local timestamp="$1"

    if [[ "$OSTYPE" == "darwin"* ]]; then
      # macOS
      date -r "$timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "Invalid timestamp"
    else
      # Linux
      date -d "@$timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "Invalid timestamp"
    fi
  }

  # Call the main function when this file is executed
  status_command
}

# :command.function
bamon_add_command() {

  # src/add_command.sh
  #!/usr/bin/env bash
  # Add command implementation

  # Source the library functions

  # Get parsed arguments from bashly
  SCRIPT_NAME="${args['name']:-}"
  SCRIPT_COMMAND="${args['--command']:-}"
  SCRIPT_INTERVAL="${args['--interval']:-60}"
  SCRIPT_DESCRIPTION="${args['--description']:-}"
  SCRIPT_ENABLED="true"

  # Check for disabled flag
  if [[ -n "${args['--disabled']:-}" ]]; then
    SCRIPT_ENABLED="false"
  fi

  # Validate required arguments
  if [[ -z "$SCRIPT_NAME" ]]; then
    echo "Error: Script name is required" >&2
    echo "Usage: bamon add <name> --command <command> [options]" >&2
    exit 1
  fi

  if [[ -z "$SCRIPT_COMMAND" ]]; then
    echo "Error: Script command is required" >&2
    echo "Usage: bamon add <name> --command <command> [options]" >&2
    exit 1
  fi

  # Validate script name (alphanumeric, hyphens, underscores only)
  if [[ ! "$SCRIPT_NAME" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "Error: Script name must contain only alphanumeric characters, hyphens, and underscores" >&2
    exit 1
  fi

  # Validate interval (must be a positive integer)
  if [[ ! "$SCRIPT_INTERVAL" =~ ^[0-9]+$ ]] || [[ "$SCRIPT_INTERVAL" -le 0 ]]; then
    echo "Error: Interval must be a positive integer" >&2
    exit 1
  fi

  # Initialize configuration
  init_config
  load_config

  # Validate configuration
  if ! validate_config; then
    echo "Error: Invalid configuration file" >&2
    exit 1
  fi

  # Check if script already exists
  if script_exists "$SCRIPT_NAME"; then
    echo "Error: Script '$SCRIPT_NAME' already exists" >&2
    exit 1
  fi

  # Add the script
  if add_script "$SCRIPT_NAME" "$SCRIPT_COMMAND" "$SCRIPT_INTERVAL" "$SCRIPT_DESCRIPTION" "$SCRIPT_ENABLED"; then
    echo "Successfully added script '$SCRIPT_NAME'"
    echo "  Command: $SCRIPT_COMMAND"
    echo "  Interval: ${SCRIPT_INTERVAL}s"
    echo "  Description: ${SCRIPT_DESCRIPTION:-'No description'}"
    echo "  Enabled: $SCRIPT_ENABLED"
  else
    echo "Error: Failed to add script '$SCRIPT_NAME'" >&2
    exit 1
  fi
}

# :command.function
bamon_remove_command() {

  # src/remove_command.sh
  #!/usr/bin/env bash
  # Remove command implementation

  # Source the library functions

  # Get parsed arguments from bashly
  SCRIPT_NAME="${args['name']:-}"
  FORCE=false

  # Check for force flag
  if [[ -n "${args['--force']:-}" ]]; then
    FORCE=true
  fi

  # Validate required arguments
  if [[ -z "$SCRIPT_NAME" ]]; then
    echo "Error: Script name is required" >&2
    echo "Usage: bamon remove <name> [options]" >&2
    exit 1
  fi

  # Initialize configuration
  init_config
  load_config

  # Validate configuration
  if ! validate_config; then
    echo "Error: Invalid configuration file" >&2
    exit 1
  fi

  # Check if script exists
  if ! script_exists "$SCRIPT_NAME"; then
    echo "Error: Script '$SCRIPT_NAME' not found" >&2
    exit 1
  fi

  # Get script details for confirmation
  script_info=$(get_script "$SCRIPT_NAME")
  if [[ -n "$script_info" && "$script_info" != "{}" ]]; then
    local description=$(echo "$script_info" | yq eval '.description' - 2>/dev/null)
    local command=$(echo "$script_info" | yq eval '.command' - 2>/dev/null)

    echo "Script to be removed:"
    echo "  Name: $SCRIPT_NAME"
    echo "  Description: ${description:-'No description'}"
    echo "  Command: $command"
    echo ""

    if [[ "$FORCE" != "true" ]]; then
      read -p "Are you sure you want to remove this script? (y/N): " confirm
      if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Operation cancelled"
        exit 0
      fi
    fi
  fi

  # Remove the script
  if remove_script "$SCRIPT_NAME"; then
    echo "Successfully removed script '$SCRIPT_NAME'"
  else
    echo "Error: Failed to remove script '$SCRIPT_NAME'" >&2
    exit 1
  fi
}

# :command.function
bamon_now_command() {

  # src/now_command.sh
  #!/usr/bin/env bash
  # Now command implementation

  # Source the library functions

  # Get parsed arguments from bashly
  SCRIPT_NAME="${args['--name']:-}"
  ASYNC=false

  # Check for async flag
  if [[ -n "${args['--async']:-}" ]]; then
    ASYNC=true
  fi

  # Initialize configuration
  init_config
  load_config

  # Validate configuration
  if ! validate_config; then
    echo "Error: Invalid configuration file" >&2
    exit 1
  fi

  # Check if yq is available
  if ! command -v yq >/dev/null 2>&1; then
    echo "Error: yq is required for script execution but not found" >&2
    echo "Please install yq: brew install yq" >&2
    exit 1
  fi

  # Execute specific script or all scripts
  if [[ -n "$SCRIPT_NAME" ]]; then
    # Execute specific script
    if ! script_exists "$SCRIPT_NAME"; then
      echo "Error: Script '$SCRIPT_NAME' not found" >&2
      exit 1
    fi

    echo "Executing script: $SCRIPT_NAME"
    echo "================================"

    if execute_scripts "$SCRIPT_NAME"; then
      echo "Script execution completed successfully"
    else
      echo "Script execution failed"
      exit 1
    fi
  else
    # Execute all enabled scripts
    echo "Executing all enabled scripts"
    echo "============================="

    if execute_all_scripts; then
      echo "All scripts executed successfully"
    else
      echo "Some scripts failed"
      exit 1
    fi
  fi
}

# :command.function
bamon_start_command() {

  # src/start_command.sh
  #!/usr/bin/env bash
  # Start command implementation

  # Source the library functions

  # Get parsed arguments from bashly
  DAEMON_MODE=false
  CONFIG_FILE=""

  # Check for daemon mode flag
  if [[ -n "${args['--daemon']:-}" ]]; then
    DAEMON_MODE=true
  fi

  # Get config file if provided
  CONFIG_FILE="${args['--config']:-}"

  # Set custom config file if provided
  if [[ -n "$CONFIG_FILE" ]]; then
    export BAMON_CONFIG_FILE="$CONFIG_FILE"
  fi

  # Initialize configuration
  init_config
  load_config

  # Validate configuration
  if ! validate_config; then
    echo "Error: Invalid configuration file" >&2
    exit 1
  fi

  # Check if yq is available
  if ! command -v yq >/dev/null 2>&1; then
    echo "Error: yq is required for daemon operation but not found" >&2
    echo "Please install yq: brew install yq" >&2
    exit 1
  fi

  # Start the daemon
  start_daemon "$DAEMON_MODE"
}

# :command.function
bamon_stop_command() {

  # src/stop_command.sh
  #!/usr/bin/env bash
  # Stop command implementation

  # Source the library functions

  # Parse command line arguments
  FORCE=false

  while [[ $# -gt 0 ]]; do
    case $1 in
      --force|-f)
        FORCE=true
        shift
        ;;
      --help|-h)
        # Help is handled by the main script
        exit 0
        ;;
      *)
        echo "Unknown option: $1" >&2
        exit 1
        ;;
    esac
  done

  # Initialize configuration
  init_config
  load_config

  # Stop the daemon
  stop_daemon "$FORCE"
}

# :command.function
bamon_restart_command() {

  # src/restart_command.sh
  #!/usr/bin/env bash
  # Restart command implementation

  # Source the library functions

  # Get parsed arguments from bashly
  DAEMON_MODE=false
  CONFIG_FILE=""

  # Check for daemon mode flag
  if [[ -n "${args['--daemon']:-}" ]]; then
    DAEMON_MODE=true
  fi

  # Get config file if provided
  CONFIG_FILE="${args['--config']:-}"

  # Set custom config file if provided
  if [[ -n "$CONFIG_FILE" ]]; then
    export BAMON_CONFIG_FILE="$CONFIG_FILE"
  fi

  # Initialize configuration
  init_config
  load_config

  # Validate configuration
  if ! validate_config; then
    echo "Error: Invalid configuration file" >&2
    exit 1
  fi

  # Check if yq is available
  if ! command -v yq >/dev/null 2>&1; then
    echo "Error: yq is required for daemon operation but not found" >&2
    echo "Please install yq: brew install yq" >&2
    exit 1
  fi

  # Stop the daemon first
  echo "Stopping daemon..."
  stop_daemon false

  # Wait a moment
  sleep 2

  # Start the daemon
  echo "Starting daemon..."
  start_daemon "$DAEMON_MODE"
}

# :command.function
bamon_list_command() {

  # src/list_command.sh
  #!/usr/bin/env bash
  # List command implementation

  # Source the library functions

  # Get parsed arguments from bashly
  ENABLED_ONLY=false
  DISABLED_ONLY=false

  # Check for filter flags
  if [[ -n "${args['--enabled-only']:-}" ]]; then
    ENABLED_ONLY=true
  fi

  if [[ -n "${args['--disabled-only']:-}" ]]; then
    DISABLED_ONLY=true
  fi

  # Initialize configuration
  init_config
  load_config

  # Validate configuration
  if ! validate_config; then
    echo "Error: Invalid configuration file" >&2
    exit 1
  fi

  # Get all scripts
  scripts_yaml=$(yq eval '.scripts[]' "${CONFIG_FILE}" 2>/dev/null)

  if [[ -z "$scripts_yaml" ]]; then
    echo "No scripts configured"
    exit 0
  fi

  # Function to display a script
  function display_script() {
    if [[ -z "$script_name" ]]; then
      return
    fi

    # Apply filters
    if [[ "$ENABLED_ONLY" == "true" && "$script_enabled" != "true" ]]; then
      return
    fi

    if [[ "$DISABLED_ONLY" == "true" && "$script_enabled" == "true" ]]; then
      return
    fi

    # Display script info
    local status_color=""
    if [[ "$script_enabled" == "true" ]]; then
      status_color="\033[0;32m"  # Green
    else
      status_color="\033[0;33m"  # Yellow
    fi

    echo -e "${status_color}${script_name}${status_color}\033[0m"

    if [[ -n "$script_description" && "$script_description" != '""' ]]; then
      echo "  Description: $script_description"
    fi

    echo "  Command: $script_command"
    echo "  Interval: ${script_interval}s"
    echo "  Enabled: $script_enabled"
    echo ""
  }

  # Display scripts
  echo "Configured Scripts:"
  echo "=================="

  # Parse each script
  local script_name=""
  local script_command=""
  local script_interval=""
  local script_enabled=""
  local script_description=""

  while IFS= read -r line; do
    if [[ "$line" =~ ^name:\ (.+)$ ]]; then
      # If we have a previous script, display it
      if [[ -n "$script_name" ]]; then
        display_script
      fi
      # Start new script
      script_name="${BASH_REMATCH[1]}"
      script_command=""
      script_interval=""
      script_enabled=""
      script_description=""
    elif [[ "$line" =~ ^command:\ (.+)$ ]]; then
      script_command="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ ^interval:\ (.+)$ ]]; then
      script_interval="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ ^enabled:\ (.+)$ ]]; then
      script_enabled="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ ^description:\ (.+)$ ]]; then
      script_description="${BASH_REMATCH[1]}"
    fi
  done <<< "$scripts_yaml"

  # Display the last script
  if [[ -n "$script_name" ]]; then
    display_script
  fi

  # Show summary
  local total_count=$(yq eval '.scripts | length' "${CONFIG_FILE}" 2>/dev/null || echo "0")
  local enabled_count=$(yq eval '[.scripts[] | select(.enabled == true)] | length' "${CONFIG_FILE}" 2>/dev/null || echo "0")
  local disabled_count=$(yq eval '[.scripts[] | select(.enabled == false)] | length' "${CONFIG_FILE}" 2>/dev/null || echo "0")

  echo "Summary:"
  echo "  Total scripts: $total_count"
  echo "  Enabled: $enabled_count"
  echo "  Disabled: $disabled_count"
}

# :command.function
bamon_performance_command() {

  # src/performance_command.sh
  #!/usr/bin/env bash
  # Performance command for bamon

  # Libraries are included via bashly custom_includes

  # Initialize configuration
  init_config

  # get_enabled_scripts function is provided by the main library

  # Parse command line arguments using bashly args array
  VERBOSE="${args[--verbose]:-false}"
  FORMAT="${args[--format]:-table}"

  # Handle --json flag
  if [[ "${args[--json]:-}" == "1" ]]; then
    FORMAT="json"
  fi

  # Handle case when args array is not available (direct function call)
  if [[ -z "${args[--verbose]:-}" && -n "${1:-}" ]]; then
    # Fallback to manual parsing if args array is not available
    while [[ $# -gt 0 ]]; do
      case $1 in
        --verbose|-v)
          VERBOSE=true
          shift
          ;;
        --format|-f)
          FORMAT="$2"
          shift 2
          ;;
        --json)
          FORMAT="json"
          shift
          ;;
        --help|-h)
          echo "Usage: bamon performance [options]"
          echo ""
          echo "Options:"
          echo "  --verbose, -v     Show detailed performance information"
          echo "  --format, -f      Output format: table, json (default: table)"
          echo "  --json            Output in JSON format"
          echo "  --help, -h        Show this help message"
          echo ""
          echo "Examples:"
          echo "  bamon performance              # Show basic performance metrics"
          echo "  bamon performance --verbose    # Show detailed metrics"
          echo "  bamon performance --json       # Output in JSON format"
          exit 0
          ;;
        *)
          echo "Unknown option: $1"
          echo "Use --help for usage information"
          exit 1
          ;;
      esac
    done
  fi

  # Check if daemon is running
  if ! is_daemon_running; then
    echo "Error: Daemon is not running"
    echo "Start the daemon with: bamon start --daemon"
    exit 1
  fi

  # Generate performance report
  if [[ "$FORMAT" == "json" ]]; then
    # Load performance data
    load_performance_data

    # JSON format output
    echo "{"
    echo "  \"timestamp\": \"$(date -Iseconds)\","
    echo "  \"daemon_status\": \"running\","
    echo "  \"system_metrics\": {"

    # System metrics
    local first=true
    while IFS=: read -r metric value; do
      if [[ "$first" == "true" ]]; then
        first=false
      else
        echo ","
      fi
      echo -n "    \"$metric\": $value"
    done < <(collect_performance_metrics)
    echo ""

    echo "  },"
    echo "  \"script_performance\": {"

    # Script performance
    local first=true
    for script_name in $(get_enabled_scripts); do
      if [[ "$first" == "true" ]]; then
        first=false
      else
        echo ","
      fi
      local avg_time=$(get_script_avg_execution_time "$script_name")
      local failures=$(get_script_failure_count "$script_name")
      echo -n "    \"$script_name\": {\"avg_time\": \"${avg_time}s\", \"failures\": $failures}"
    done
    echo ""

    echo "  },"
    echo "  \"cache_status\": {"
    echo "    \"ttl\": $CACHE_TTL,"
    echo "    \"cached_items\": ${#PERFORMANCE_CACHE_KEYS[@]},"
    echo "    \"cache_hits\": $CACHE_HITS,"
    echo "    \"cache_misses\": $CACHE_MISSES,"
    echo "    \"cache_evictions\": $CACHE_EVICTIONS,"
    local total_requests=$((CACHE_HITS + CACHE_MISSES))
    if [[ $total_requests -gt 0 ]]; then
      echo "    \"hit_rate\": \"$((CACHE_HITS * 100 / total_requests))%\""
    else
      echo "    \"hit_rate\": \"0%\""
    fi
    echo "  }"
    echo "}"
  else
    # Table format output (default)
    generate_performance_report

    if [[ "$VERBOSE" == "true" ]]; then
      echo ""
      echo "=== Detailed System Information ==="
      echo "Performance Monitoring: $(is_performance_monitoring_enabled && echo "Enabled" || echo "Disabled")"
      echo "Load Threshold: $(get_load_threshold)"
      echo "Cache TTL: $(get_cache_ttl) seconds"
      echo "Scheduling Optimization: $(is_scheduling_optimized && echo "Enabled" || echo "Disabled")"
      echo ""

      echo "=== Cache Contents ==="
      if [[ ${#PERFORMANCE_CACHE_KEYS[@]} -eq 0 ]]; then
        echo "No cached items"
      else
        for i in "${!PERFORMANCE_CACHE_KEYS[@]}"; do
          local key="${PERFORMANCE_CACHE_KEYS[$i]}"
          local value="${PERFORMANCE_CACHE_VALUES[$i]}"
          local cached_time="${PERFORMANCE_CACHE_TIMES[$i]}"
          local current_time=$(date +%s)
          local age=$((current_time - cached_time))
          echo "  $key: $value (age: ${age}s)"
        done
      fi
    fi
  fi

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help)
        long_usage=yes
        bamon_usage
        exit
        ;;

      # :flag.case
      --version | -V)

        # :flag.case_no_arg
        args['--version']=1
        shift
        ;;

      # :flag.case
      --help | -h)

        # :flag.case_no_arg
        args['--help']=1
        shift
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    status)
      action="status"
      shift
      bamon_status_parse_requirements "$@"
      shift $#
      ;;

    add)
      action="add"
      shift
      bamon_add_parse_requirements "$@"
      shift $#
      ;;

    remove)
      action="remove"
      shift
      bamon_remove_parse_requirements "$@"
      shift $#
      ;;

    now)
      action="now"
      shift
      bamon_now_parse_requirements "$@"
      shift $#
      ;;

    start)
      action="start"
      shift
      bamon_start_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      bamon_stop_parse_requirements "$@"
      shift $#
      ;;

    restart)
      action="restart"
      shift
      bamon_restart_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      bamon_list_parse_requirements "$@"
      shift $#
      ;;

    performance)
      action="performance"
      shift
      bamon_performance_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      bamon_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bamon_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bamon_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --failed-only | -f)

        # :flag.case_no_arg
        args['--failed-only']=1
        shift
        ;;

      # :flag.case
      --json | -j)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      # :flag.case
      --name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n SCRIPT_NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bamon_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bamon_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --command | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--command']="$2"
          shift
          shift
        else
          printf "%s\n" "--command requires an argument: --command, -c COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --interval | -i)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--interval']="$2"
          shift
          shift
        else
          printf "%s\n" "--interval requires an argument: --interval, -i SECONDS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --description | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description, -d TEXT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --enabled)

        # :flag.case_no_arg
        args['--enabled']=1
        shift
        ;;

      # :flag.case
      --disabled)

        # :flag.case_no_arg
        args['--disabled']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: bamon add NAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.required_flags_filter
  if [[ -z ${args['--command']+x} ]]; then
    printf "missing required flag: --command, -c COMMAND\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
bamon_remove_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bamon_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: bamon remove NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
bamon_now_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bamon_now_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="now"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n SCRIPT_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --async | -a)

        # :flag.case_no_arg
        args['--async']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bamon_start_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bamon_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --daemon | -d)

        # :flag.case_no_arg
        args['--daemon']=1
        shift
        ;;

      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c CONFIG_FILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bamon_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bamon_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bamon_restart_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bamon_restart_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="restart"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --daemon | -d)

        # :flag.case_no_arg
        args['--daemon']=1
        shift
        ;;

      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c CONFIG_FILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bamon_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bamon_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --enabled-only | -e)

        # :flag.case_no_arg
        args['--enabled-only']=1
        shift
        ;;

      # :flag.case
      --disabled-only | -d)

        # :flag.case_no_arg
        args['--disabled-only']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bamon_performance_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bamon_performance_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="performance"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FORMAT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --json)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "status") bamon_status_command ;;
    "add") bamon_add_command ;;
    "remove") bamon_remove_command ;;
    "now") bamon_now_command ;;
    "start") bamon_start_command ;;
    "stop") bamon_stop_command ;;
    "restart") bamon_restart_command ;;
    "list") bamon_list_command ;;
    "performance") bamon_performance_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
