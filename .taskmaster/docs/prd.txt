# Bash Daemon Monitor - Product Requirements Document

## Project Overview
A configurable bash daemon that monitors and executes bash scripts/code snippets at specified intervals, providing a CLI interface for management using the Bashly framework.

## Core Functionality

### 1. Daemon Core
- **Purpose**: Continuously monitor and execute configurable bash scripts/code snippets
- **Execution Model**: Run scripts at configurable intervals (e.g., every 30 seconds, 1 minute, 5 minutes)
- **Script Types**: 
  - Simple bash commands that return 0 (success) or 1 (failure)
  - HTTP health checks (e.g., `curl -s -o /dev/null -w "%{http_code}" https://google.com`)
  - Custom bash scripts with configurable execution intervals
- **Configuration**: YAML-based configuration file for script definitions and intervals
- **Logging**: Comprehensive logging with configurable levels (DEBUG, INFO, WARN, ERROR)
  - **Daemon Mode**: All output (stdout and stderr) redirected to single log file
  - **Log File**: `~/.config/bamon/daemon.log` (configurable via config.yaml)
  - **Log Rotation**: Automatic log rotation to prevent disk space issues
  - **Log Levels**: Configurable verbosity levels for different environments
- **Sandboxing**: All script executions run in isolated environment with resource limits

### 2. Script Management
- **Add Scripts**: Add new monitoring scripts with custom intervals
- **Remove Scripts**: Remove existing scripts from monitoring
- **List Scripts**: Display all configured scripts with their status
- **Script Status**: Real-time status of each script (running, failed, success)
- **Execution History**: Track execution times, success/failure rates, and output
- **Enhanced Status Check**: Comprehensive status reporting with execution details
  - **Success/Failure Status**: Clear indication of script execution results
  - **Output Capture**: Display both stdout and stderr from last execution
  - **Execution Metadata**: Show execution time, timestamp, and exit codes
  - **Output Display**: Context-aware output reporting with specific content types
    - **Successful Executions**: Display stdout output from successful script execution
    - **Failed Executions**: Display error messages with specific failure types
      - **Timeout Errors**: "Timeout after Xs" (using sandbox.timeout configuration)
      - **Memory Errors**: "Memory error" for memory-related failures
      - **Permission Issues**: "Permission denied" for access problems
      - **File Issues**: "File not found" for missing files
      - **Network Issues**: "Network error" for connection problems
      - **Custom Scripts**: Show actual output for custom failing scripts
      - **Generic Failures**: "Failed (exit code: X)" for other errors
    - **Table View**: Output truncated to 25 characters with "truncated (use --json)" hint for full details
    - **JSON View**: Complete output available without truncation
  - **JSON Support**: Optional JSON output format for programmatic access
  - **Real-time Data**: Show current status without triggering new executions

### 3. CLI Interface (Bashly-based)
- **status**: Show current status of all monitored scripts with detailed execution results
  - Display success/failure status for each script
  - Show output from last execution (stdout for success, error details for failure)
  - Include execution time and timestamp
  - Support JSON output format with `--json` flag for complete output details
- **add**: Add new script to monitoring with interval configuration
- **remove**: Remove script from monitoring
- **list**: List all configured scripts with details
- **now**: Execute all scripts immediately (manual trigger)
- **start**: Start the daemon process
- **stop**: Stop the daemon process
- **restart**: Restart the daemon process
- **performance**: Show system performance metrics and optimization status
- **config**: Configuration management commands
  - **config edit**: Open configuration file in default editor for manual editing
  - **config show**: Display current configuration in YAML format
  - **config validate**: Validate configuration file syntax and structure

### 4. Daemon Logging
- **Background Mode**: When running `bamon start --daemon`, all output is redirected to a single log file
- **Log File Location**: `~/.config/bamon/daemon.log` (configurable via `daemon.log_file` in config.yaml)
- **Output Redirection**: Both stdout and stderr are combined into the single log file using `2>&1`
- **Foreground Mode**: When running `bamon start` (without --daemon), output appears in the terminal
- **Log Content**: Includes all script execution results, errors, and daemon status messages
- **Log Rotation**: Automatic log rotation to prevent disk space issues (configurable)

### 5. Configuration Format
```yaml
daemon:
  default_interval: 60
  log_file: "~/.config/bamon/daemon.log"
  pid_file: "~/.config/bamon/bamon.pid"
  max_concurrent: 10
  history_file: "~/.config/bamon/execution_history.json"
  history_retention_days: 30

sandbox:
  timeout: 30
  max_cpu_time: 60
  max_file_size: 10240
  max_virtual_memory: 102400

performance:
  enable_monitoring: true
  load_threshold: 0.8
  optimize_scheduling: true

scripts:
  - name: "health_check"
    command: "curl -s -o /dev/null -w '%{http_code}' https://google.com"
    interval: 30
    enabled: true
  - name: "disk_space"
    command: "df -h / | awk 'NR==2 {print $5}' | sed 's/%//'"
    interval: 300
    enabled: true
```

## Technical Requirements

### 1. Dependencies
- **Runtime**: bash 4.0+, curl, yq, timeout/gtimeout, standard Unix tools
- **Development**: Ruby, bashly gem, bash 4.0+
- **Optional**: systemd (for service management)

### 2. File Structure
```
bamon/
├── bamon                    # Main executable (generated by bashly)
├── bashly.yml              # Bashly configuration
├── src/
│   ├── lib/
│   │   ├── config.sh       # Configuration management
│   │   ├── execution.sh    # Script execution and daemon loop
│   │   ├── logging.sh      # Logging functions
│   │   ├── sandbox.sh      # Script sandboxing
│   │   └── performance.sh  # Performance optimization
│   └── *_command.sh        # CLI command implementations
├── config.yaml             # Daemon configuration
└── install.sh              # Installation script
```

### 3. Security Features
- **Sandboxing**: All scripts run with resource limits (CPU, memory, file size, timeout)
- **Path Isolation**: Scripts run in temporary directories with limited access
- **Resource Limits**: Configurable limits prevent system overload
- **Input Validation**: All inputs validated before execution

### 4. Status Check Implementation
- **Execution History Storage**: Store last execution results for each script
  - Success/failure status and exit codes
  - Complete stdout and stderr output
  - Execution timestamps and duration
  - Resource usage metrics
  - Intelligent error message generation
- **Status Display Format**:
  - **Human-readable**: Tabular format with clear status indicators
    - **Column Layout**: NAME | STATUS | EXIT CODE | OUTPUT | DURATION | TIME SINCE | NEXT EXECUTION
    - **Column Widths**: Optimized widths based on data patterns (OUTPUT: 25 chars, DURATION: 8 chars)
    - **Table View**: Removed LAST EXECUTION column for cleaner layout (available in JSON)
  - **JSON format**: Structured data with `--json` flag for API integration
    - **Complete Data**: Includes all execution details including last execution timestamp
  - **Filtering**: Show only failed scripts with `--failed-only` flag
  - **Sorting**: Sort by status, execution time, or script name
  - **Output Column**: Context-aware output display for all scripts
    - **Success**: Shows stdout output (truncated to 25 chars in table view)
    - **Failure**: Shows error messages (truncated to 25 chars in table view)
    - **Empty Output**: Shows "(no output)" placeholder for scripts with no output
    - **Truncation Hint**: "truncated (use --json)" for table view
- **Output Intelligence**:
  - **Success Output**: Captures and displays stdout from successful script execution
  - **Failure Analysis**: Analyzes exit codes and output patterns for intelligent error reporting
    - **Timeout Detection**: Analyzes exit code 124 and "timed out" output patterns
    - **Resource Error Detection**: Identifies memory, permission, and file access issues
    - **Network Error Detection**: Recognizes connection and network-related failures
    - **Custom Script Support**: Preserves original output for custom failing scripts
    - **Configuration Integration**: Uses sandbox.timeout for accurate timeout reporting
  - **Display Optimization**: Smart truncation for table view with full details in JSON
- **Data Persistence**: Store execution history in configurable location
  - Default: `~/.config/bamon/execution_history.json`
  - Configurable via `daemon.history_file` setting
  - Automatic cleanup of old entries based on retention policy

## Performance Optimization

### 1. System Load Monitoring
- **Load Detection**: Monitor system load average and prevent execution during high load
- **Resource Awareness**: Track CPU, memory, and disk usage
- **Adaptive Scheduling**: Adjust execution intervals based on system performance

### 2. Concurrent Execution Management
- **Max Concurrent**: Limit number of simultaneously running scripts
- **Queue Management**: Queue scripts when system is at capacity
- **Priority Scheduling**: Execute high-priority scripts first

### 3. Optimization
- **Efficient File Operations**: Minimize disk I/O with optimized file handling
- **Associative Arrays**: Use Bash 4.0+ associative arrays for O(1) performance

### 4. Performance Metrics
- **Execution Times**: Track and optimize script execution duration
- **Success Rates**: Monitor and report script success/failure rates
- **Resource Usage**: Track CPU, memory, and disk usage per script
- **System Health**: Overall system performance indicators

## Installation and Distribution

### 1. Installation Script (`install.sh`)
- **Simplified Installation**: Direct installation without build dependencies
- **Dependency Check**: Validates and installs required runtime dependencies
- **Binary Installation**: Copies pre-built binary from repository
- **Configuration Setup**: Creates default configuration and directories
- **Sample Scripts**: Installs sample monitoring scripts
- **PATH Setup**: Automatically adds installation directory to user's PATH

### 2. User Installation (Runtime) - Recommended
**Requirements:**
- bash 4.0+ (system default or Homebrew)
- curl (for HTTP health checks)
- yq (YAML processor)
- timeout/gtimeout (GNU coreutils)
- Standard Unix tools (awk, sed, grep, etc.)

**Process:**
1. Clone repository: `git clone <repo-url>`
2. Run: `chmod +x install.sh && ./install.sh`
3. Binary installed to `/usr/local/bin/bamon` (system) or `~/.local/bin/bamon` (user)
4. Configuration created at `~/.config/bamon/config.yaml`
5. Sample scripts installed to `~/.config/bamon/samples/`
6. Ready to use with `bamon start`

**Installation Modes:**
- **User Installation** (default): `./install.sh` - Installs to `~/.local/bin/`
- **System Installation**: `sudo ./install.sh --system` - Installs to `/usr/local/bin/`
- **Custom Installation**: `./install.sh --prefix=/custom/path` - Custom installation directory

### 3. Developer Installation (Full Development Setup)
**Requirements:**
- Ruby 2.7+ (for bashly)
- bashly gem (`gem install bashly`)
- bash 4.0+ (Homebrew version recommended)
- Git (for version control)

**Process:**
1. Clone repository: `git clone <repo-url>`
2. Install Ruby and bashly:
   ```bash
   # macOS with Homebrew
   brew install ruby
   export PATH="/opt/homebrew/opt/ruby/bin:$PATH"
   export PATH="$(ruby -r rubygems -e "puts Gem.bindir"):$PATH"
   gem install bashly
   
   # Ubuntu/Debian
   sudo apt install ruby ruby-dev
   gem install bashly
   ```
3. Generate binary: `bashly generate`
4. Test: `./bamon --help`
5. For development: `./install.sh --dev` (if available)

### 4. Documentation Requirements
**Comprehensive Documentation** must include:

#### 4.1 Installation Documentation
- **Quick Start Guide**: Simple installation using `install.sh` script
- **Full Development Setup**: Complete development environment with Ruby and Bashly
- **Platform-Specific Instructions**: macOS, Linux, and WSL2 installation steps
- **Dependency Installation**: Step-by-step dependency installation for each platform
- **Troubleshooting**: Common installation issues and solutions

#### 4.2 Usage Documentation
- **README.md**: Comprehensive project overview with installation and usage
- **Command Reference**: Complete CLI command documentation with examples
- **Configuration Guide**: YAML configuration file documentation with examples
- **Sample Scripts**: Documentation for included sample monitoring scripts
- **Best Practices**: Recommended usage patterns and configuration examples

#### 4.3 Developer Documentation
- **Development Setup**: Complete development environment setup instructions
- **Build Process**: How to build and regenerate the binary with Bashly
- **Code Structure**: Overview of source code organization and architecture
- **Contributing Guide**: How to contribute to the project
- **Testing**: How to run tests and validate changes

#### 4.4 Advanced Documentation
- **Man Pages**: Unix manual pages for all commands (`bamon.1`, `bamon-status.1`, etc.)
- **API Documentation**: JSON output format and programmatic usage
- **Integration Examples**: CI/CD, monitoring, and cloud integration examples
- **Performance Tuning**: Configuration optimization and performance guidelines
- **Security Guide**: Security considerations and best practices

### 4. Cross-Platform Support
- **macOS**: Full support with Homebrew dependencies
- **Linux**: Native support with package manager dependencies
- **Windows**: WSL2 support with Linux dependencies

### 5. Ubuntu Container Testing Environment
- **Purpose**: Comprehensive testing in isolated Ubuntu environment to validate installation, functionality, and cross-platform compatibility
- **Container Setup**: Fresh Ubuntu container (latest LTS) with no pre-installed dependencies
- **Installation Testing**: Test complete installation process including all required binaries
- **Test Framework**: BATS (Bash Automated Testing System) for comprehensive test coverage
- **Test Structure**:
  - `test/` directory with complete test suite
  - `test/config.yaml` with test configuration
  - All CLI commands and paths tested
  - Daemon functionality validation
  - Performance monitoring verification
  - JSON output validation
  - Error handling and edge cases
- **Deployment Process**:
  1. Start fresh Ubuntu container
  2. Install system dependencies (bash, curl, jq, yq, etc.)
  3. Install bamon via installation script
  4. Run comprehensive test suite
  5. Validate all functionality works correctly
- **Success Criteria**: All tests pass in clean Ubuntu environment

## Success Criteria

### 1. Functional Requirements
- ✅ Daemon runs continuously without crashes
- ✅ Scripts execute at configured intervals
- ✅ CLI commands work correctly
- ✅ Configuration management functions properly
- ✅ Logging captures all events appropriately
- ✅ Sandboxing prevents system damage
- ✅ Performance optimization reduces resource usage
- ✅ Installation script works on target platforms

### 2. Performance Requirements
- **Resource Usage**: < 10MB RAM, < 1% CPU when idle
- **Response Time**: CLI commands respond within 1 second
- **Concurrent Execution**: Support up to 10 simultaneous scripts
- **System Load**: Adapt to system load and prevent overload

### 3. Security Requirements
- **Sandboxing**: All scripts run in isolated environment
- **Resource Limits**: Prevent runaway scripts from consuming resources
- **Input Validation**: All inputs validated before processing
- **Error Handling**: Graceful handling of script failures

### 4. Usability Requirements
- **Simple Installation**: One-command installation process
- **Clear Documentation**: Comprehensive README and help text
- **Intuitive CLI**: Easy-to-use command interface
- **Configuration**: Simple YAML configuration format
- **Troubleshooting**: Clear error messages and logging

## Future Enhancements

### 1. Advanced Features
- **Web Dashboard**: Web interface for monitoring and management
- **Alerting**: Email/SMS notifications for script failures
- **Metrics Export**: Prometheus/InfluxDB metrics export
- **Plugin System**: Extensible plugin architecture

### 2. Enterprise Features
- **Multi-User Support**: User-based script management
- **Centralized Management**: Central configuration management
- **Audit Logging**: Comprehensive audit trail
- **High Availability**: Clustering and failover support

### 3. Integration Features
- **CI/CD Integration**: GitHub Actions, Jenkins integration
- **Monitoring Integration**: Nagios, Zabbix, Datadog integration
- **Cloud Integration**: AWS, Azure, GCP monitoring
- **Container Support**: Docker, Kubernetes integration