# Task ID: 14
# Title: Implement Performance Optimization
# Status: in-progress
# Dependencies: 3, 12
# Priority: medium
# Description: Implement comprehensive performance optimization including system load monitoring, resource management, caching, and efficient script scheduling with full compatibility for Bash 4.0+ (system default or Homebrew).
# Details:
1. Create `src/lib/performance.sh` with comprehensive performance functions using modern Bash 4.0+ features:
```bash
#!/usr/bin/env bash

source "${BASH_SOURCE%/*}/config.sh"
source "${BASH_SOURCE%/*}/logging.sh"

# Performance monitoring variables using associative arrays (Bash 4.0+ feature)
declare -A PERFORMANCE_CACHE
declare -A PERFORMANCE_CACHE_TIMES
declare -A SCRIPT_EXECUTION_TIMES
declare -A SCRIPT_FAILURE_COUNTS
declare -A SYSTEM_LOAD_VALUES

# Cache TTL (Time To Live) in seconds
CACHE_TTL=30
LAST_CACHE_UPDATE=0

# Performance configuration functions
function get_performance_config() {
  local key="$1"
  local default="$2"
  get_config_value "performance.$key" "$default"
}

function is_performance_monitoring_enabled() {
  get_performance_config "enable_monitoring" "true"
}

function get_load_threshold() {
  get_performance_config "load_threshold" "0.8"
}

function get_cache_ttl() {
  get_performance_config "cache_ttl" "30"
}

function is_scheduling_optimized() {
  get_performance_config "optimize_scheduling" "true"
}

# System load monitoring
function get_system_load() {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS: use sysctl
    sysctl -n vm.loadavg | awk '{print $1}'
  else
    # Linux: use /proc/loadavg
    cat /proc/loadavg | cut -d' ' -f1
  fi
}

function get_cpu_cores() {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    sysctl -n hw.ncpu
  else
    nproc
  fi
}

function is_system_overloaded() {
  if ! is_performance_monitoring_enabled; then
    return 1
  fi
  
  local load=$(get_system_load)
  local cores=$(get_cpu_cores)
  local threshold=$(get_load_threshold)
  local max_load=$(echo "$cores * $threshold" | bc -l)
  
  if (( $(echo "$load > $max_load" | bc -l) )); then
    log_warn "System load is high: $load (threshold: $max_load)"
    return 0  # true, system is overloaded
  fi
  return 1  # false, system is not overloaded
}

# Resource monitoring
function get_memory_usage() {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS: use vm_stat
    vm_stat | grep "Pages free" | awk '{print $3}' | sed 's/\.//'
  else
    # Linux: use /proc/meminfo
    free | grep Mem | awk '{print $3/$2 * 100.0}'
  fi
}

function get_disk_usage() {
  df -h / | awk 'NR==2 {print $5}' | sed 's/%//'
}

# Concurrent execution management
function count_running_scripts() {
  local count=0
  local pid_file=$(get_pid_file)
  
  if [[ -f "$pid_file" ]]; then
    local daemon_pid=$(cat "$pid_file")
    if kill -0 "$daemon_pid" 2>/dev/null; then
      count=$(pgrep -P "$daemon_pid" | wc -l)
    fi
  fi
  
  echo "$count"
}

function can_run_more_scripts() {
  local max_concurrent=$(get_max_concurrent)
  local running=$(count_running_scripts)
  
  if [[ $running -ge $max_concurrent ]]; then
    log_debug "At max concurrent capacity: $running/$max_concurrent"
    return 1  # false, at max capacity
  fi
  
  # Check system load
  if is_system_overloaded; then
    return 1  # false, system is overloaded
  fi
  
  return 0  # true, can run more scripts
}

# Caching system using associative arrays
function get_cached_value() {
  local key="$1"
  local current_time=$(date +%s)
  
  if [[ -n "${PERFORMANCE_CACHE[$key]}" ]]; then
    local cached_time="${PERFORMANCE_CACHE_TIMES[$key]}"
    local age=$((current_time - cached_time))
    
    if [[ $age -lt $CACHE_TTL ]]; then
      echo "${PERFORMANCE_CACHE[$key]}"
      return 0
    fi
  fi
  
  return 1
}

function set_cached_value() {
  local key="$1"
  local value="$2"
  local current_time=$(date +%s)
  
  PERFORMANCE_CACHE[$key]="$value"
  PERFORMANCE_CACHE_TIMES[$key]="$current_time"
}

# Script execution tracking using associative arrays
function track_script_execution() {
  local script_name="$1"
  local execution_time="$2"
  local success="$3"
  
  SCRIPT_EXECUTION_TIMES[$script_name]="$execution_time"
  
  if [[ "$success" == "false" ]]; then
    SCRIPT_FAILURE_COUNTS[$script_name]=$((${SCRIPT_FAILURE_COUNTS[$script_name]:-0} + 1))
  fi
}

function get_script_avg_execution_time() {
  local script_name="$1"
  echo "${SCRIPT_EXECUTION_TIMES[$script_name]:-0}"
}

function get_script_failure_count() {
  local script_name="$1"
  echo "${SCRIPT_FAILURE_COUNTS[$script_name]:-0}"
}

# Optimized script scheduling
function optimize_schedule() {
  if ! is_scheduling_optimized; then
    get_enabled_scripts
    return
  fi
  
  # Get all enabled scripts with their intervals and execution times
  local scripts_info=()
  
  while IFS= read -r script_name; do
    local interval=$(get_script_interval "$script_name")
    local avg_time=$(get_script_avg_execution_time "$script_name")
    local failures=$(get_script_failure_count "$script_name")
    
    # Calculate priority score (lower is better)
    # Prioritize: shorter intervals, faster execution, fewer failures
    local priority_score=$(echo "$interval + $avg_time - ($failures * 10)" | bc -l)
    
    scripts_info+=("$priority_score:$script_name")
  done < <(get_enabled_scripts)
  
  # Sort by priority score and return script names
  printf '%s\n' "${scripts_info[@]}" | sort -n | cut -d: -f2
}

# Performance metrics collection
function collect_performance_metrics() {
  local metrics=()
  
  metrics+=("load:$(get_system_load)")
  metrics+=("memory:$(get_memory_usage)")
  metrics+=("disk:$(get_disk_usage)")
  metrics+=("running_scripts:$(count_running_scripts)")
  metrics+=("max_concurrent:$(get_max_concurrent)")
  
  printf '%s\n' "${metrics[@]}"
}

# Performance report
function generate_performance_report() {
  echo "=== BAMON Performance Report ==="
  echo "Timestamp: $(date)"
  echo ""
  
  echo "System Metrics:"
  collect_performance_metrics | while IFS=: read -r metric value; do
    echo "  $metric: $value"
  done
  echo ""
  
  echo "Script Performance:"
  for script_name in $(get_enabled_scripts); do
    local avg_time=$(get_script_avg_execution_time "$script_name")
    local failures=$(get_script_failure_count "$script_name")
    echo "  $script_name: avg_time=${avg_time}s, failures=$failures"
  done
  echo ""
  
  echo "Cache Status:"
  echo "  Cache TTL: ${CACHE_TTL}s"
  echo "  Cached items: ${#PERFORMANCE_CACHE[@]}"
}

# Cleanup old cache entries
function cleanup_cache() {
  local current_time=$(date +%s)
  
  for key in "${!PERFORMANCE_CACHE[@]}"; do
    local cached_time="${PERFORMANCE_CACHE_TIMES[$key]}"
    local age=$((current_time - cached_time))
    
    if [[ $age -gt $CACHE_TTL ]]; then
      unset PERFORMANCE_CACHE[$key]
      unset PERFORMANCE_CACHE_TIMES[$key]
    fi
  done
}
```
2. Add performance configuration functions to `src/lib/config.sh`
3. Integrate performance monitoring into `src/lib/execution.sh`
4. Add performance CLI command to show metrics
5. Implement efficient file operations and caching
6. Add system resource monitoring and adaptive scheduling
7. Use modern Bash 4.0+ features like associative arrays for better performance
8. Use portable syntax for cross-platform compatibility between macOS and Linux
9. Use bc for all floating-point calculations to ensure compatibility
10. Verify integration with the logging library (src/lib/logging.sh)

# Test Strategy:
1. Test performance monitoring under various system loads
2. Verify caching improves performance for frequent operations
3. Test concurrent execution limits with resource monitoring
4. Measure and validate performance metrics collection
5. Test adaptive scheduling with different script configurations
6. Verify performance report generation and accuracy
7. Test compatibility with Bash 4.0+ on macOS (system default or Homebrew)
8. Test compatibility with newer Bash versions (4.2+, 5.3.3) on Linux
9. Verify proper integration with the logging system
10. Test error handling when performance functions are called
11. Test sandbox timeout configuration with the fixed sandbox.sh implementation
12. Verify performance optimization with modern Bash features
13. Test with both system default bash and Homebrew bash on macOS

# Subtasks:
## 1. Implement associative arrays for performance monitoring [in-progress]
### Dependencies: None
### Description: Use Bash 4.0+ associative arrays for efficient key-value storage in the performance monitoring system
### Details:
1. Replace parallel array implementation with proper associative arrays
2. Use declare -A for all key-value data structures
3. Update all functions to use associative array syntax
4. Optimize lookup operations using direct key access

## 2. Implement efficient caching system [in-progress]
### Dependencies: None
### Description: Create functions to store and retrieve cached values using associative arrays for optimal performance
### Details:
1. Use associative arrays for the caching system
2. Implement TTL (Time To Live) functionality
3. Create efficient cache cleanup mechanism
4. Add cache statistics tracking

## 3. Verify logging integration [in-progress]
### Dependencies: None
### Description: Ensure performance library properly integrates with the logging library and uses appropriate log levels
### Details:


## 4. Test with Bash 4.0+ versions [not-started]
### Dependencies: None
### Description: Verify the performance library works correctly with Bash 4.0+ on different platforms
### Details:
1. Test with system default bash on macOS (if 4.0+)
2. Test with Homebrew bash on macOS
3. Test with modern bash on Linux
4. Verify all features work consistently across all bash versions
5. Utilize Bash 4.0+ features for optimal performance

## 5. Update performance CLI command [not-started]
### Dependencies: None
### Description: Ensure the performance command works with the refactored library and displays metrics correctly
### Details:


## 6. Integrate with fixed sandbox timeout configuration [not-started]
### Dependencies: None
### Description: Ensure performance monitoring works correctly with the fixed sandbox timeout configuration in execute_sandboxed_from_config function
### Details:
1. Verify that performance monitoring correctly tracks script execution with the fixed sandbox timeout
2. Update performance metrics to include timeout information
3. Test with scripts that should timeout after 3 seconds as configured in config.yaml

## 7. Test performance with sandbox timeout configuration [not-started]
### Dependencies: 14.6
### Description: Test performance optimization with the fixed sandbox timeout configuration to ensure proper resource management
### Details:
1. Test performance with various timeout configurations
2. Verify that performance monitoring correctly adapts to different timeout settings
3. Ensure that resource management works correctly with timed-out scripts

## 8. Optimize date operations for performance [not-started]
### Dependencies: None
### Description: Implement efficient date operations using modern Bash features for better performance
### Details:
1. Use modern date command features for timestamp generation
2. Optimize date arithmetic operations for cache TTL calculations
3. Implement efficient time-based operations for performance metrics
4. Use built-in Bash arithmetic where possible instead of external commands

## 9. Optimize associative array operations [not-started]
### Dependencies: 14.1, 14.2
### Description: Optimize associative array operations for maximum performance
### Details:
1. Benchmark associative array performance
2. Optimize key access patterns
3. Implement efficient iteration over associative arrays
4. Optimize memory usage for large datasets

## 10. Implement advanced performance metrics [not-started]
### Dependencies: 14.1
### Description: Add advanced performance metrics collection using modern Bash capabilities
### Details:
1. Add detailed CPU utilization metrics
2. Implement memory usage tracking per script
3. Add disk I/O monitoring
4. Create network usage metrics if applicable
5. Implement trend analysis for performance over time

