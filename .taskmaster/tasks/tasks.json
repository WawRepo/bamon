{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Structure with Bashly",
        "description": "Initialize the project structure using Bashly framework to create the CLI application skeleton.",
        "details": "1. Install Bashly if not already installed: `gem install bashly`\n2. Create project directory: `mkdir bash-daemon-monitor && cd bash-daemon-monitor`\n3. Initialize Bashly project: `bashly init`\n4. Define the basic command structure in bashly.yml:\n```yaml\nname: bamon\nhelp: Bash Daemon Monitor - A tool for monitoring and executing bash scripts\nversion: 0.1.0\ncommands:\n  - name: status\n    help: Display current status of all configured scripts\n    flags:\n      - long: --verbose\n        short: -v\n        help: Show detailed information including full output\n      - long: --failed-only\n        short: -f\n        help: Show only failed scripts\n  - name: add\n    help: Add a new script to monitor\n    args:\n      - name: name\n        required: true\n        help: Script name/ID\n    flags:\n      - long: --command\n        short: -c\n        arg: command\n        required: true\n        help: Bash command/code to execute\n      - long: --interval\n        short: -i\n        arg: seconds\n        help: Execution interval in seconds\n      - long: --description\n        short: -d\n        arg: text\n        help: Description of what the script does\n      - long: --enabled\n        help: Set script as enabled (default)\n      - long: --disabled\n        help: Set script as disabled\n  # Add other commands structure\n```\n5. Generate the initial CLI structure: `bashly generate`\n6. Test the basic CLI: `./bamon --help`",
        "testStrategy": "1. Verify Bashly installation works correctly\n2. Ensure the generated CLI structure matches the requirements\n3. Test the help command to verify all required commands are present\n4. Verify the version information is displayed correctly",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Configuration File Management",
        "description": "Create functionality to read, write, and validate the YAML configuration file that stores script definitions and global settings.",
        "details": "1. Create a lib directory for helper functions: `mkdir -p src/lib`\n2. Create configuration management functions in `src/lib/config.sh`:\n```bash\n#!/usr/bin/env bash\n\nCONFIG_FILE=\"${HOME}/.config/bamon/config.yaml\"\n\n# Create default config if it doesn't exist\nfunction init_config() {\n  local config_dir=\"$(dirname \"${CONFIG_FILE}\")\"\n  \n  if [[ ! -d \"$config_dir\" ]]; then\n    mkdir -p \"$config_dir\"\n  fi\n  \n  if [[ ! -f \"${CONFIG_FILE}\" ]]; then\n    cat > \"${CONFIG_FILE}\" << EOF\ndaemon:\n  default_interval: 60\n  log_file: \"${HOME}/.local/share/bamon/logs/bamon.log\"\n  pid_file: \"${HOME}/.local/share/bamon/bamon.pid\"\n  max_concurrent: 10\n\nscripts: []\nEOF\n  fi\n}\n\n# Load config file\nfunction load_config() {\n  if [[ ! -f \"${CONFIG_FILE}\" ]]; then\n    init_config\n  fi\n  \n  # Use yq or another YAML parser to read config\n  # For simplicity, we'll assume yq is installed\n  # In a real implementation, you might want to include a pure bash YAML parser\n}\n\n# Save config file\nfunction save_config() {\n  # Implementation to save config changes\n}\n\n# Validate config file\nfunction validate_config() {\n  # Check if config file is valid YAML\n  # Verify required fields exist\n  # Return 0 if valid, 1 if invalid\n}\n```\n3. Create functions to add, remove, and update script entries\n4. Implement config file path customization via environment variable or command line option\n5. Add error handling for file operations",
        "testStrategy": "1. Test creating a new config file with default values\n2. Verify reading from an existing config file works correctly\n3. Test adding, updating, and removing script entries\n4. Validate error handling for invalid YAML or missing required fields\n5. Test with custom config file paths",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Daemon Core Functionality",
        "description": "Create the core daemon functionality that runs in the background and executes scripts at specified intervals.",
        "details": "1. Create `src/lib/daemon.sh` with core daemon functions:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/config.sh\"\nsource \"${BASH_SOURCE%/*}/logger.sh\"\n\n# Start daemon process\nfunction start_daemon() {\n  local daemon_mode=$1\n  load_config\n  \n  # Check if daemon is already running\n  if is_daemon_running; then\n    echo \"Daemon is already running with PID $(cat \"$(get_pid_file)\")\"\n    return 1\n  fi\n  \n  # If daemon mode, fork to background\n  if [[ \"$daemon_mode\" == \"true\" ]]; then\n    nohup \"$0\" daemon_run > /dev/null 2>&1 &\n    echo $! > \"$(get_pid_file)\"\n    echo \"Daemon started with PID $!\"\n  else\n    # Run in foreground\n    daemon_run\n  fi\n}\n\n# Main daemon loop\nfunction daemon_run() {\n  log_info \"Daemon started\"\n  \n  # Set up trap for clean shutdown\n  trap shutdown SIGINT SIGTERM\n  \n  # Main loop\n  while true; do\n    # Get all enabled scripts\n    local scripts=$(get_enabled_scripts)\n    \n    # Check which scripts need to be run\n    for script in $scripts; do\n      if should_run_script \"$script\"; then\n        execute_script \"$script\"\n      fi\n    done\n    \n    # Sleep for a short time before checking again\n    sleep 5\n  done\n}\n\n# Execute a script\nfunction execute_script() {\n  local script_name=$1\n  local script_command=$(get_script_command \"$script_name\")\n  local max_concurrent=$(get_max_concurrent)\n  \n  # Check if we're already at max concurrent executions\n  local running_count=$(count_running_scripts)\n  if [[ $running_count -ge $max_concurrent ]]; then\n    log_warn \"Max concurrent executions reached, delaying $script_name\"\n    return\n  fi\n  \n  # Execute script in background with timeout\n  log_info \"Executing script: $script_name\"\n  {\n    local start_time=$(date +%s)\n    local output\n    local exit_code\n    \n    # Execute with timeout\n    output=$(timeout 30s bash -c \"$script_command\" 2>&1)\n    exit_code=$?\n    \n    local end_time=$(date +%s)\n    local duration=$((end_time - start_time))\n    \n    # Update script status in config\n    update_script_status \"$script_name\" \"$exit_code\" \"$output\" \"$duration\"\n    \n    if [[ $exit_code -eq 0 ]]; then\n      log_info \"Script $script_name completed successfully in ${duration}s\"\n    else\n      log_error \"Script $script_name failed with exit code $exit_code in ${duration}s\"\n      log_error \"Output: $output\"\n    fi\n  } &\n}\n\n# Check if script should be run based on its interval\nfunction should_run_script() {\n  local script_name=$1\n  local last_run=$(get_script_last_run \"$script_name\")\n  local interval=$(get_script_interval \"$script_name\")\n  local now=$(date +%s)\n  \n  # If never run or interval has passed\n  if [[ -z \"$last_run\" || $((now - last_run)) -ge $interval ]]; then\n    return 0\n  fi\n  \n  return 1\n}\n\n# Shutdown daemon gracefully\nfunction shutdown() {\n  log_info \"Shutting down daemon\"\n  # Clean up PID file\n  rm -f \"$(get_pid_file)\"\n  exit 0\n}\n```\n2. Implement script execution with proper timeout handling\n3. Add concurrency control to limit simultaneous script executions\n4. Implement interval-based execution scheduling\n5. Add proper signal handling for graceful shutdown",
        "testStrategy": "1. Test daemon startup in both foreground and background modes\n2. Verify script execution at specified intervals\n3. Test concurrent execution limits\n4. Verify proper handling of script timeouts\n5. Test graceful shutdown with signal handling\n6. Verify PID file management",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Logging System",
        "description": "Create a logging system with different log levels, proper formatting, and log rotation capabilities.",
        "details": "1. Create `src/lib/logger.sh` with logging functions:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/config.sh\"\n\n# Log levels\nDEBUG=0\nINFO=1\nWARN=2\nERROR=3\n\n# Current log level (default: INFO)\nLOG_LEVEL=$INFO\n\n# Get log file path from config\nfunction get_log_file() {\n  local log_file=$(yq e '.daemon.log_file' \"$CONFIG_FILE\")\n  echo \"${log_file/#~/$HOME}\"\n}\n\n# Initialize log file\nfunction init_logger() {\n  local log_file=$(get_log_file)\n  local log_dir=$(dirname \"$log_file\")\n  \n  if [[ ! -d \"$log_dir\" ]]; then\n    mkdir -p \"$log_dir\"\n  fi\n  \n  # Check if log rotation is needed\n  if [[ -f \"$log_file\" ]]; then\n    local size=$(stat -c%s \"$log_file\" 2>/dev/null || stat -f%z \"$log_file\")\n    if [[ $size -gt 10485760 ]]; then  # 10MB in bytes\n      rotate_logs\n    fi\n  fi\n}\n\n# Rotate log files\nfunction rotate_logs() {\n  local log_file=$(get_log_file)\n  local max_logs=7\n  \n  # Remove oldest log if it exists\n  if [[ -f \"${log_file}.${max_logs}\" ]]; then\n    rm \"${log_file}.${max_logs}\"\n  fi\n  \n  # Shift log files\n  for i in $(seq $((max_logs-1)) -1 1); do\n    if [[ -f \"${log_file}.${i}\" ]]; then\n      mv \"${log_file}.${i}\" \"${log_file}.$((i+1))\"\n    fi\n  done\n  \n  # Move current log to .1\n  if [[ -f \"$log_file\" ]]; then\n    mv \"$log_file\" \"${log_file}.1\"\n  fi\n  \n  # Create new log file\n  touch \"$log_file\"\n}\n\n# Log message with level\nfunction log() {\n  local level=$1\n  local script_name=$2\n  local message=$3\n  \n  # Check if we should log this message based on level\n  if [[ $level -lt $LOG_LEVEL ]]; then\n    return\n  fi\n  \n  # Get level name\n  local level_name=\"UNKNOWN\"\n  case $level in\n    $DEBUG) level_name=\"DEBUG\" ;;\n    $INFO) level_name=\"INFO\" ;;\n    $WARN) level_name=\"WARN\" ;;\n    $ERROR) level_name=\"ERROR\" ;;\n  esac\n  \n  # Format timestamp\n  local timestamp=$(date \"+%Y-%m-%d %H:%M:%S\")\n  \n  # Format log message\n  local log_message=\"[$timestamp] [$level_name] \"\n  if [[ -n \"$script_name\" ]]; then\n    log_message+=\"[$script_name] \"\n  fi\n  log_message+=\"$message\"\n  \n  # Write to log file\n  init_logger\n  echo \"$log_message\" >> \"$(get_log_file)\"\n}\n\n# Convenience functions for different log levels\nfunction log_debug() { log $DEBUG \"\" \"$1\"; }\nfunction log_info() { log $INFO \"\" \"$1\"; }\nfunction log_warn() { log $WARN \"\" \"$1\"; }\nfunction log_error() { log $ERROR \"\" \"$1\"; }\n\n# Script-specific logging\nfunction log_script_debug() { log $DEBUG \"$1\" \"$2\"; }\nfunction log_script_info() { log $INFO \"$1\" \"$2\"; }\nfunction log_script_warn() { log $WARN \"$1\" \"$2\"; }\nfunction log_script_error() { log $ERROR \"$1\" \"$2\"; }\n```\n2. Implement log rotation based on file size (10MB)\n3. Add log retention policy (7 days)\n4. Create helper functions for different log levels\n5. Ensure log directory exists and is writable",
        "testStrategy": "1. Test logging at different log levels\n2. Verify log file creation and directory structure\n3. Test log rotation when file size exceeds 10MB\n4. Verify log retention policy keeps only 7 days of logs\n5. Test script-specific logging format",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Status Command",
        "description": "Create the status command to display the current status of all configured scripts with options for verbose output and filtering failed scripts.",
        "details": "1. Implement the status command in `src/status_command.sh`:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\n\nfunction status_command() {\n  local verbose=${args[--verbose]}\n  local failed_only=${args[--failed-only]}\n  \n  # Load config\n  load_config\n  \n  # Get daemon status\n  if is_daemon_running; then\n    local pid=$(cat \"$(get_pid_file)\")\n    echo \"Daemon: RUNNING (PID: $pid)\"\n  else\n    echo \"Daemon: STOPPED\"\n  fi\n  echo \"\"\n  \n  # Get all scripts\n  local scripts=$(get_all_scripts)\n  if [[ -z \"$scripts\" ]]; then\n    echo \"No scripts configured. Use 'bamon add' to add scripts.\"\n    return\n  fi\n  \n  # Print header\n  printf \"%-20s %-10s %-20s %-20s\\n\" \"NAME\" \"STATUS\" \"LAST RUN\" \"NEXT RUN\"\n  printf \"%s\\n\" \"$(printf '%.0s-' {1..70})\"\n  \n  # Print each script status\n  for script in $scripts; do\n    local status=$(get_script_status \"$script\")\n    local last_run=$(get_script_last_run_formatted \"$script\")\n    local next_run=$(get_script_next_run_formatted \"$script\")\n    local enabled=$(is_script_enabled \"$script\" && echo \"true\" || echo \"false\")\n    \n    # Skip if we're only showing failed scripts and this one is OK\n    if [[ \"$failed_only\" == \"true\" && \"$status\" != \"FAILED\" && \"$status\" != \"ERROR\" ]]; then\n      continue\n    fi\n    \n    # If script is disabled, show DISABLED status\n    if [[ \"$enabled\" != \"true\" ]]; then\n      status=\"DISABLED\"\n    fi\n    \n    # Print basic status line\n    printf \"%-20s %-10s %-20s %-20s\\n\" \"$script\" \"$status\" \"$last_run\" \"$next_run\"\n    \n    # If verbose and script has output, show it\n    if [[ \"$verbose\" == \"true\" ]]; then\n      local output=$(get_script_last_output \"$script\")\n      if [[ -n \"$output\" ]]; then\n        echo \"  Output:\"\n        echo \"$output\" | sed 's/^/    /'\n      fi\n      \n      # Show script details\n      local command=$(get_script_command \"$script\")\n      local interval=$(get_script_interval \"$script\")\n      local description=$(get_script_description \"$script\")\n      \n      echo \"  Details:\"\n      echo \"    Command: $command\"\n      echo \"    Interval: $interval seconds\"\n      if [[ -n \"$description\" ]]; then\n        echo \"    Description: $description\"\n      fi\n      echo \"\"\n    fi\n  done\n}\n```\n2. Implement helper functions to get script status, last run time, next run time\n3. Format output in a readable table format\n4. Add support for verbose output with full command and last output\n5. Implement filtering for failed scripts only",
        "testStrategy": "1. Test status command with no scripts configured\n2. Test with multiple scripts in different states (OK, FAILED, DISABLED)\n3. Verify verbose output shows additional details\n4. Test failed-only filter shows only failed scripts\n5. Verify formatting is consistent and readable",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Add Command",
        "description": "Create the add command to register new scripts for monitoring with validation of inputs.",
        "details": "1. Implement the add command in `src/add_command.sh`:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\nsource \"${BASH_SOURCE%/*}/lib/logger.sh\"\n\nfunction add_command() {\n  local name=${args[name]}\n  local command=${args[--command]}\n  local interval=${args[--interval]}\n  local description=${args[--description]}\n  local disabled=${args[--disabled]}\n  \n  # Load config\n  load_config\n  \n  # Validate script name (alphanumeric and underscores only)\n  if ! [[ $name =~ ^[a-zA-Z0-9_]+$ ]]; then\n    echo \"Error: Script name must contain only alphanumeric characters and underscores\"\n    return 1\n  fi\n  \n  # Check if script already exists\n  if script_exists \"$name\"; then\n    echo \"Error: Script '$name' already exists\"\n    return 1\n  fi\n  \n  # Validate command (basic check that it's not empty)\n  if [[ -z \"$command\" ]]; then\n    echo \"Error: Command cannot be empty\"\n    return 1\n  fi\n  \n  # Set default interval if not provided\n  if [[ -z \"$interval\" ]]; then\n    interval=$(get_default_interval)\n  fi\n  \n  # Validate interval is a positive integer\n  if ! [[ $interval =~ ^[0-9]+$ ]] || [[ $interval -le 0 ]]; then\n    echo \"Error: Interval must be a positive integer\"\n    return 1\n  fi\n  \n  # Determine enabled status\n  local enabled=true\n  if [[ \"$disabled\" == \"true\" ]]; then\n    enabled=false\n  fi\n  \n  # Add script to config\n  add_script_to_config \"$name\" \"$command\" \"$interval\" \"$enabled\" \"$description\"\n  \n  echo \"Script '$name' added successfully\"\n  echo \"  Command: $command\"\n  echo \"  Interval: $interval seconds\"\n  echo \"  Enabled: $enabled\"\n  if [[ -n \"$description\" ]]; then\n    echo \"  Description: $description\"\n  fi\n  \n  # Log the addition\n  log_info \"Added new script: $name\"\n  \n  return 0\n}\n```\n2. Implement validation for script name, command, and interval\n3. Add function to check if script already exists\n4. Create function to add script to configuration file\n5. Provide feedback on successful addition",
        "testStrategy": "1. Test adding a script with all required parameters\n2. Test adding a script with optional parameters\n3. Verify validation rejects invalid script names\n4. Test duplicate script name handling\n5. Verify script is correctly added to configuration file\n6. Test with various interval values including defaults",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Remove Command",
        "description": "Create the remove command to delete scripts from monitoring with confirmation and force options.",
        "details": "1. Implement the remove command in `src/remove_command.sh`:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\nsource \"${BASH_SOURCE%/*}/lib/logger.sh\"\n\nfunction remove_command() {\n  local name=${args[--name]}\n  local force=${args[--force]}\n  \n  # Load config\n  load_config\n  \n  # Check if script exists\n  if ! script_exists \"$name\"; then\n    echo \"Error: Script '$name' does not exist\"\n    return 1\n  fi\n  \n  # Confirm removal if not forced\n  if [[ \"$force\" != \"true\" ]]; then\n    read -p \"Are you sure you want to remove script '$name'? [y/N] \" confirm\n    if [[ ! $confirm =~ ^[Yy]$ ]]; then\n      echo \"Removal cancelled\"\n      return 0\n    fi\n  fi\n  \n  # Remove script from config\n  remove_script_from_config \"$name\"\n  \n  echo \"Script '$name' removed successfully\"\n  \n  # Log the removal\n  log_info \"Removed script: $name\"\n  \n  return 0\n}\n```\n2. Implement validation to check if script exists\n3. Add confirmation prompt with option to bypass with --force\n4. Create function to remove script from configuration file\n5. Provide feedback on successful removal",
        "testStrategy": "1. Test removing an existing script with confirmation\n2. Test removing an existing script with --force option\n3. Verify error handling when script doesn't exist\n4. Test cancellation of removal when user doesn't confirm\n5. Verify script is correctly removed from configuration file",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Now Command",
        "description": "Create the now command to execute scripts immediately, either all enabled scripts or a specific one by name.",
        "details": "1. Implement the now command in `src/now_command.sh`:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\nsource \"${BASH_SOURCE%/*}/lib/logger.sh\"\n\nfunction now_command() {\n  local name=${args[--name]}\n  local async=${args[--async]}\n  \n  # Load config\n  load_config\n  \n  # If specific script is specified, check if it exists\n  if [[ -n \"$name\" ]] && ! script_exists \"$name\"; then\n    echo \"Error: Script '$name' does not exist\"\n    return 1\n  fi\n  \n  # Get scripts to execute\n  local scripts\n  if [[ -n \"$name\" ]]; then\n    # Check if script is enabled\n    if ! is_script_enabled \"$name\"; then\n      echo \"Error: Script '$name' is disabled\"\n      return 1\n    fi\n    scripts=\"$name\"\n  else\n    scripts=$(get_enabled_scripts)\n    if [[ -z \"$scripts\" ]]; then\n      echo \"No enabled scripts found\"\n      return 0\n    fi\n  fi\n  \n  echo \"Executing scripts...\"\n  \n  # Track PIDs if running async\n  local pids=()\n  \n  # Execute each script\n  for script in $scripts; do\n    echo \"Running '$script'...\"\n    \n    local command=$(get_script_command \"$script\")\n    local start_time=$(date +%s)\n    \n    if [[ \"$async\" == \"true\" ]]; then\n      # Run in background\n      {\n        local output\n        local exit_code\n        \n        output=$(bash -c \"$command\" 2>&1)\n        exit_code=$?\n        \n        local end_time=$(date +%s)\n        local duration=$((end_time - start_time))\n        \n        # Update script status\n        update_script_status \"$script\" \"$exit_code\" \"$output\" \"$duration\"\n        \n        # Print result\n        if [[ $exit_code -eq 0 ]]; then\n          echo \"'$script' completed successfully in ${duration}s\"\n        else\n          echo \"'$script' failed with exit code $exit_code in ${duration}s\"\n          echo \"Output: $output\"\n        fi\n      } &\n      \n      pids+=($!)\n    else\n      # Run synchronously\n      local output\n      local exit_code\n      \n      output=$(bash -c \"$command\" 2>&1)\n      exit_code=$?\n      \n      local end_time=$(date +%s)\n      local duration=$((end_time - start_time))\n      \n      # Update script status\n      update_script_status \"$script\" \"$exit_code\" \"$output\" \"$duration\"\n      \n      # Print result\n      if [[ $exit_code -eq 0 ]]; then\n        echo \"'$script' completed successfully in ${duration}s\"\n      else\n        echo \"'$script' failed with exit code $exit_code in ${duration}s\"\n        echo \"Output: $output\"\n      fi\n    fi\n  done\n  \n  # If async, wait for all processes to complete\n  if [[ \"$async\" == \"true\" ]] && [[ ${#pids[@]} -gt 0 ]]; then\n    echo \"Waiting for all scripts to complete...\"\n    for pid in \"${pids[@]}\"; do\n      wait \"$pid\"\n    done\n    echo \"All scripts completed\"\n  fi\n  \n  return 0\n}\n```\n2. Implement script execution with proper output capture\n3. Add support for executing a specific script by name\n4. Implement asynchronous execution option\n5. Update script status after execution\n6. Provide real-time feedback on execution results",
        "testStrategy": "1. Test executing all enabled scripts\n2. Test executing a specific script by name\n3. Verify error handling for non-existent scripts\n4. Test asynchronous execution with multiple scripts\n5. Verify script status is updated after execution\n6. Test execution of scripts with different exit codes",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Start/Stop/Restart Commands",
        "description": "Create commands to start, stop, and restart the daemon process with appropriate options and error handling.",
        "details": "1. Implement the start command in `src/start_command.sh`:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\nsource \"${BASH_SOURCE%/*}/lib/daemon.sh\"\nsource \"${BASH_SOURCE%/*}/lib/logger.sh\"\n\nfunction start_command() {\n  local daemon_mode=${args[--daemon]}\n  local config_file=${args[--config]}\n  \n  # Set custom config file if specified\n  if [[ -n \"$config_file\" ]]; then\n    if [[ ! -f \"$config_file\" ]]; then\n      echo \"Error: Config file '$config_file' does not exist\"\n      return 1\n    fi\n    export CONFIG_FILE=\"$config_file\"\n  fi\n  \n  # Check if daemon is already running\n  if is_daemon_running; then\n    echo \"Daemon is already running with PID $(cat \"$(get_pid_file)\")\"\n    return 1\n  fi\n  \n  # Start daemon\n  if [[ \"$daemon_mode\" == \"true\" ]]; then\n    echo \"Starting daemon in background...\"\n    start_daemon true\n  else\n    echo \"Starting daemon in foreground (press Ctrl+C to stop)...\"\n    start_daemon false\n  fi\n  \n  return 0\n}\n```\n\n2. Implement the stop command in `src/stop_command.sh`:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\nsource \"${BASH_SOURCE%/*}/lib/logger.sh\"\n\nfunction stop_command() {\n  local force=${args[--force]}\n  \n  # Check if daemon is running\n  if ! is_daemon_running; then\n    echo \"Daemon is not running\"\n    return 1\n  fi\n  \n  local pid=$(cat \"$(get_pid_file)\")\n  \n  echo \"Stopping daemon (PID: $pid)...\"\n  \n  # Send signal to daemon\n  if [[ \"$force\" == \"true\" ]]; then\n    # Force kill\n    kill -9 \"$pid\" 2>/dev/null\n  else\n    # Graceful shutdown\n    kill -15 \"$pid\" 2>/dev/null\n  fi\n  \n  # Wait for process to terminate\n  local timeout=10\n  local count=0\n  while kill -0 \"$pid\" 2>/dev/null && [[ $count -lt $timeout ]]; do\n    sleep 1\n    ((count++))\n  done\n  \n  # Check if process is still running\n  if kill -0 \"$pid\" 2>/dev/null; then\n    echo \"Failed to stop daemon within $timeout seconds\"\n    echo \"Use --force to forcefully terminate the process\"\n    return 1\n  else\n    echo \"Daemon stopped\"\n    # Remove PID file if it still exists\n    if [[ -f \"$(get_pid_file)\" ]]; then\n      rm -f \"$(get_pid_file)\"\n    fi\n    return 0\n  fi\n}\n```\n\n3. Implement the restart command in `src/restart_command.sh`:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\n\nfunction restart_command() {\n  local daemon_mode=${args[--daemon]}\n  local config_file=${args[--config]}\n  \n  # Stop daemon if running\n  if is_daemon_running; then\n    echo \"Stopping daemon...\"\n    \"$0\" stop\n    \n    # Check if stop was successful\n    if [[ $? -ne 0 ]]; then\n      echo \"Failed to stop daemon, cannot restart\"\n      return 1\n    fi\n  fi\n  \n  # Start daemon again\n  echo \"Starting daemon...\"\n  \n  # Build start command with appropriate options\n  local start_cmd=\"$0 start\"\n  if [[ \"$daemon_mode\" == \"true\" ]]; then\n    start_cmd+=\"--daemon\"\n  fi\n  if [[ -n \"$config_file\" ]]; then\n    start_cmd+=\" --config '$config_file'\"\n  fi\n  \n  eval \"$start_cmd\"\n  return $?\n}\n```\n\n4. Add helper function to check if daemon is running\n5. Implement proper signal handling for graceful shutdown\n6. Add support for custom config file path",
        "testStrategy": "1. Test starting daemon in both foreground and background modes\n2. Verify daemon can be stopped gracefully\n3. Test force stopping a daemon that doesn't respond to normal signals\n4. Verify restart command correctly stops and starts the daemon\n5. Test error handling when daemon is already running or not running\n6. Verify custom config file option works correctly",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement List Command",
        "description": "Create the list command to display all configured scripts with filtering options for enabled and disabled scripts.",
        "details": "1. Implement the list command in `src/list_command.sh`:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\n\nfunction list_command() {\n  local enabled_only=${args[--enabled-only]}\n  local disabled_only=${args[--disabled-only]}\n  \n  # Load config\n  load_config\n  \n  # Get all scripts\n  local scripts=$(get_all_scripts)\n  if [[ -z \"$scripts\" ]]; then\n    echo \"No scripts configured. Use 'bamon add' to add scripts.\"\n    return 0\n  fi\n  \n  # Print header\n  printf \"%-20s %-10s %-10s %-40s\\n\" \"NAME\" \"ENABLED\" \"INTERVAL\" \"DESCRIPTION\"\n  printf \"%s\\n\" \"$(printf '%.0s-' {1..80})\"\n  \n  # Print each script\n  for script in $scripts; do\n    local enabled=$(is_script_enabled \"$script\" && echo \"true\" || echo \"false\")\n    local interval=$(get_script_interval \"$script\")\n    local description=$(get_script_description \"$script\")\n    \n    # Apply filters\n    if [[ \"$enabled_only\" == \"true\" && \"$enabled\" != \"true\" ]]; then\n      continue\n    fi\n    if [[ \"$disabled_only\" == \"true\" && \"$enabled\" != \"false\" ]]; then\n      continue\n    fi\n    \n    # Print script info\n    printf \"%-20s %-10s %-10s %-40s\\n\" \"$script\" \"$enabled\" \"${interval}s\" \"${description:0:40}\"\n  done\n  \n  return 0\n}\n```\n2. Implement filtering for enabled and disabled scripts\n3. Format output in a readable table format\n4. Add helper functions to get script properties\n5. Provide feedback when no scripts are configured",
        "testStrategy": "1. Test listing all scripts\n2. Test filtering for only enabled scripts\n3. Test filtering for only disabled scripts\n4. Verify formatting is consistent and readable\n5. Test with no scripts configured\n6. Verify long descriptions are truncated appropriately",
        "priority": "low",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Error Handling and Input Validation",
        "description": "Create comprehensive error handling and input validation for all commands and operations.",
        "details": "1. Create `src/lib/validation.sh` for input validation functions:\n```bash\n#!/usr/bin/env bash\n\n# Validate script name (alphanumeric and underscores only)\nfunction validate_script_name() {\n  local name=$1\n  if ! [[ $name =~ ^[a-zA-Z0-9_]+$ ]]; then\n    return 1\n  fi\n  return 0\n}\n\n# Validate interval is a positive integer\nfunction validate_interval() {\n  local interval=$1\n  if ! [[ $interval =~ ^[0-9]+$ ]] || [[ $interval -le 0 ]]; then\n    return 1\n  fi\n  return 0\n}\n\n# Validate bash command syntax (basic check)\nfunction validate_command() {\n  local command=$1\n  \n  # Check if command is empty\n  if [[ -z \"$command\" ]]; then\n    return 1\n  fi\n  \n  # Basic syntax check (this is a simplified check)\n  if ! bash -n <(echo \"$command\") 2>/dev/null; then\n    return 1\n  fi\n  \n  return 0\n}\n\n# Sanitize user input to prevent command injection\nfunction sanitize_input() {\n  local input=$1\n  # Remove potentially dangerous characters\n  echo \"$input\" | tr -d '\\\\`$&|;()<>'\n}\n```\n2. Update all commands to use validation functions\n3. Add error handling for file operations\n4. Implement input sanitization to prevent command injection\n5. Add validation for configuration file format\n6. Create helper functions for common error messages",
        "testStrategy": "1. Test validation functions with valid and invalid inputs\n2. Verify error handling for file operations (read/write failures)\n3. Test input sanitization prevents command injection\n4. Verify configuration validation catches malformed YAML\n5. Test error handling for concurrent access to configuration file\n6. Verify appropriate error messages are displayed for all error conditions",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Script Execution Sandboxing",
        "description": "Create a sandboxed environment for script execution with resource limits and timeout handling.",
        "details": "1. Create `src/lib/sandbox.sh` for script execution in a controlled environment:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/logger.sh\"\n\n# Execute script in a sandboxed environment\nfunction execute_sandboxed() {\n  local script_name=$1\n  local command=$2\n  local timeout=$3\n  \n  if [[ -z \"$timeout\" ]]; then\n    timeout=30  # Default timeout: 30 seconds\n  fi\n  \n  log_debug \"Executing '$script_name' in sandbox with ${timeout}s timeout\"\n  \n  # Create temporary directory for script\n  local temp_dir=$(mktemp -d)\n  local temp_script=\"${temp_dir}/script.sh\"\n  \n  # Write command to temporary script\n  cat > \"$temp_script\" << EOF\n#!/usr/bin/env bash\nset -e\n$command\nEOF\n  \n  chmod +x \"$temp_script\"\n  \n  # Execute with resource limits\n  local output\n  local exit_code\n  \n  # Use timeout and ulimit to restrict resources\n  output=$(\n    ulimit -t $((timeout * 2)) -f 10240 -v 102400 && \\\n    timeout ${timeout}s \"$temp_script\" 2>&1\n  )\n  exit_code=$?\n  \n  # Clean up temporary files\n  rm -rf \"$temp_dir\"\n  \n  # Handle timeout specifically\n  if [[ $exit_code -eq 124 ]]; then\n    log_error \"Script '$script_name' timed out after ${timeout}s\"\n    output=\"ERROR: Script execution timed out after ${timeout} seconds\\n${output}\"\n  fi\n  \n  # Return results\n  echo \"$exit_code:$output\"\n}\n```\n2. Update script execution in daemon and now command to use sandboxed execution\n3. Implement resource limits (CPU, memory, disk I/O)\n4. Add timeout handling with configurable timeout value\n5. Create temporary directory for each script execution\n6. Implement cleanup of temporary files after execution",
        "testStrategy": "1. Test script execution with various resource-intensive scripts\n2. Verify timeout handling stops scripts that run too long\n3. Test resource limits prevent excessive resource usage\n4. Verify temporary files are cleaned up after execution\n5. Test error handling for scripts that attempt to access restricted resources\n6. Verify sandbox doesn't interfere with legitimate script functionality",
        "priority": "medium",
        "dependencies": [
          3,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Create Installation Script",
        "description": "Develop comprehensive installation scripts for both user and developer installations with clear separation of requirements.",
        "details": "1. Create `install.sh` script with dual installation modes:\n```bash\n#!/usr/bin/env bash\n\nset -e\n\n# Installation modes\nMODE=\"\"\nINSTALL_DIR=\"/usr/local/bin\"\nCONFIG_DIR=\"/etc/bamon\"\nUSER_CONFIG_DIR=\"$HOME/.config/bamon\"\n\n# Parse command line arguments\nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n    --user)\n      MODE=\"user\"\n      INSTALL_DIR=\"$HOME/.local/bin\"\n      CONFIG_DIR=\"$USER_CONFIG_DIR\"\n      shift\n      ;;\n    --system)\n      MODE=\"system\"\n      shift\n      ;;\n    --dev)\n      MODE=\"dev\"\n      shift\n      ;;\n    --prefix=*)\n      INSTALL_DIR=\"${1#*=}\"\n      shift\n      ;;\n    --config-dir=*)\n      CONFIG_DIR=\"${1#*=}\"\n      shift\n      ;;\n    --help)\n      echo \"Usage: $0 [--user|--system|--dev] [options]\"\n      echo \"Modes:\"\n      echo \"  --user     User installation (default)\"\n      echo \"  --system   System-wide installation (requires root)\"\n      echo \"  --dev      Developer installation\"\n      echo \"Options:\"\n      echo \"  --prefix=DIR       Install binary to DIR\"\n      echo \"  --config-dir=DIR   Install config to DIR\"\n      echo \"  --help             Show this help message\"\n      exit 0\n      ;;\n    *)\n      echo \"Unknown option: $1\"\n      exit 1\n      ;;\n  esac\ndone\n\n# Default to user mode if not specified\nif [[ -z \"$MODE\" ]]; then\n  MODE=\"user\"\n  INSTALL_DIR=\"$HOME/.local/bin\"\n  CONFIG_DIR=\"$USER_CONFIG_DIR\"\nfi\n\n# Check requirements based on mode\nif [[ \"$MODE\" == \"dev\" ]]; then\n  # Developer requirements\n  echo \"Checking developer requirements...\"\n  \n  if ! command -v ruby &>/dev/null; then\n    echo \"Error: Ruby is required for development\"\n    echo \"Install with: brew install ruby (macOS) or apt install ruby (Linux)\"\n    exit 1\n  fi\n  \n  if ! command -v bashly &>/dev/null; then\n    echo \"Installing bashly...\"\n    gem install bashly\n  fi\n  \n  if ! command -v git &>/dev/null; then\n    echo \"Error: Git is required for development\"\n    exit 1\n  fi\n  \n  echo \"Developer setup complete!\"\n  echo \"Run 'bashly generate' to create the binary\"\n  exit 0\nfi\n\n# User/System installation requirements\nif [[ \"$MODE\" == \"system\" && \"$(id -u)\" -ne 0 ]]; then\n  echo \"Error: System installation requires root privileges\"\n  echo \"Run with sudo or use --user for user installation\"\n  exit 1\nfi\n\n# Check runtime dependencies\necho \"Checking runtime dependencies...\"\n\n# Check bash version\nif ! bash --version | grep -q \"version 4\"; then\n  echo \"Warning: Bash 4.0+ recommended. Current version:\"\n  bash --version | head -1\nfi\n\n# Check for required tools\nMISSING_DEPS=()\n\nif ! command -v curl &>/dev/null; then\n  MISSING_DEPS+=(\"curl\")\nfi\n\nif ! command -v yq &>/dev/null; then\n  MISSING_DEPS+=(\"yq\")\nfi\n\n# Check for timeout command (gtimeout on macOS)\nif [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n  if ! command -v gtimeout &>/dev/null; then\n    MISSING_DEPS+=(\"coreutils (for gtimeout)\")\n  fi\nelse\n  if ! command -v timeout &>/dev/null; then\n    MISSING_DEPS+=(\"timeout\")\n  fi\nfi\n\nif [[ ${#MISSING_DEPS[@]} -gt 0 ]]; then\n  echo \"Missing dependencies: ${MISSING_DEPS[*]}\"\n  echo \"Install with:\"\n  if [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n    echo \"  brew install curl yq coreutils\"\n  else\n    echo \"  sudo apt install curl yq coreutils (Ubuntu/Debian)\"\n    echo \"  sudo yum install curl yq coreutils (RHEL/CentOS)\"\n  fi\n  exit 1\nfi\n\n# Generate binary if not exists\nif [[ ! -f \"./bamon\" ]]; then\n  if command -v bashly &>/dev/null; then\n    echo \"Generating binary...\"\n    bashly generate\n  else\n    echo \"Error: Binary not found and bashly not available\"\n    echo \"Run with --dev mode first to set up development environment\"\n    exit 1\n  fi\nfi\n\n# Create installation directories\necho \"Creating directories...\"\nmkdir -p \"$INSTALL_DIR\"\nmkdir -p \"$CONFIG_DIR\"\n\n# Install binary\necho \"Installing binary to $INSTALL_DIR/bamon...\"\ncp \"./bamon\" \"$INSTALL_DIR/\"\nchmod +x \"$INSTALL_DIR/bamon\"\n\n# Install default config with performance settings\nif [[ ! -f \"$CONFIG_DIR/config.yaml\" ]]; then\n  echo \"Installing default config to $CONFIG_DIR/config.yaml...\"\n  cat > \"$CONFIG_DIR/config.yaml\" << EOF\ndaemon:\n  default_interval: 60\n  log_file: \"$CONFIG_DIR/bamon.log\"\n  pid_file: \"$CONFIG_DIR/bamon.pid\"\n  max_concurrent: 10\n\nsandbox:\n  timeout: 30\n  max_cpu_time: 60\n  max_file_size: 10240\n  max_virtual_memory: 102400\n\nperformance:\n  enable_monitoring: true\n  load_threshold: 0.8\n  cache_ttl: 30\n  optimize_scheduling: true\n\nscripts: []\nEOF\nfi\n\n# Add to PATH if user installation\nif [[ \"$MODE\" == \"user\" ]]; then\n  if ! echo \"$PATH\" | grep -q \"$INSTALL_DIR\"; then\n    echo \"Adding $INSTALL_DIR to PATH...\"\n    echo \"export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"\" >> \"$HOME/.bashrc\"\n    echo \"export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"\" >> \"$HOME/.zshrc\"\n    echo \"Please restart your shell or run: source ~/.bashrc\"\n  fi\nfi\n\necho \"Installation complete!\"\necho \"Run 'bamon --help' to get started\"\n```\n2. Add performance configuration to default config\n3. Support both user and system installation modes\n4. Clear separation of user vs developer requirements\n5. Cross-platform dependency detection and installation guidance\n6. Automatic PATH configuration for user installations",
        "testStrategy": "1. Test user installation mode on clean system\n2. Test system installation mode with root privileges\n3. Test developer installation mode with missing dependencies\n4. Verify cross-platform dependency detection (macOS, Linux)\n5. Test PATH configuration for user installations\n6. Verify performance settings are included in default config",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement command-line argument parsing",
            "description": "Create the command-line argument parsing logic for the installation script to handle different installation modes and options.",
            "dependencies": [],
            "details": "Implement the argument parsing section that handles --user, --system, --dev modes and options like --prefix, --config-dir. Include help text display and validation of arguments. Ensure proper default values are set when no arguments are provided.",
            "status": "done",
            "testStrategy": "Test with various combinations of arguments to verify correct mode selection. Verify help text is displayed with --help. Test invalid arguments trigger appropriate error messages."
          },
          {
            "id": 2,
            "title": "Implement dependency checking for different installation modes",
            "description": "Create the dependency checking logic that verifies all required tools and dependencies are available based on the selected installation mode.",
            "dependencies": [
              "13.1"
            ],
            "details": "Implement checks for runtime dependencies (curl, yq, timeout/gtimeout) and development dependencies (ruby, bashly, git). Add cross-platform detection for macOS vs Linux. Provide helpful installation instructions when dependencies are missing.",
            "status": "done",
            "testStrategy": "Test dependency checking on different platforms. Verify appropriate error messages when dependencies are missing. Test with all installation modes to ensure mode-specific dependencies are correctly verified."
          },
          {
            "id": 3,
            "title": "Implement directory creation and binary installation",
            "description": "Create the logic for setting up installation directories and copying the binary to the appropriate location based on installation mode.",
            "dependencies": [
              "13.1",
              "13.2"
            ],
            "details": "Implement directory creation for installation and configuration directories. Add logic to copy the binary to the correct location and set appropriate permissions. Include binary generation using bashly when in development mode or when binary doesn't exist.",
            "status": "done",
            "testStrategy": "Test directory creation with different installation modes. Verify binary is correctly copied and permissions are set. Test binary generation when in development mode."
          },
          {
            "id": 4,
            "title": "Implement configuration file generation",
            "description": "Create the logic for generating and installing the default configuration file with performance settings.",
            "dependencies": [
              "13.3"
            ],
            "details": "Implement the creation of the default config.yaml file with appropriate settings for daemon, sandbox, and performance sections. Ensure the configuration is only created if it doesn't already exist to prevent overwriting user configurations.",
            "status": "done",
            "testStrategy": "Test configuration file generation with different installation modes. Verify the generated configuration contains all required sections. Test that existing configuration files are not overwritten."
          },
          {
            "id": 5,
            "title": "Implement PATH configuration and installation completion",
            "description": "Create the logic for adding the installation directory to PATH for user installations and displaying completion messages.",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "Implement PATH configuration for user installations by updating .bashrc and .zshrc files. Add completion messages that provide information about next steps. Include verification that the installation was successful.",
            "status": "done",
            "testStrategy": "Test PATH configuration for user installations. Verify shell configuration files are correctly updated. Test completion messages provide accurate information about next steps."
          }
        ]
      },
      {
        "id": 14,
        "title": "Implement Performance Optimization",
        "description": "Implement comprehensive performance optimization including system load monitoring, resource management, caching, and efficient script scheduling with full compatibility for Bash 4.0+ (system default or Homebrew).",
        "status": "in-progress",
        "dependencies": [
          3,
          12
        ],
        "priority": "medium",
        "details": "1. Create `src/lib/performance.sh` with comprehensive performance functions using modern Bash 4.0+ features:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/config.sh\"\nsource \"${BASH_SOURCE%/*}/logging.sh\"\n\n# Performance monitoring variables using associative arrays (Bash 4.0+ feature)\ndeclare -A PERFORMANCE_CACHE\ndeclare -A PERFORMANCE_CACHE_TIMES\ndeclare -A SCRIPT_EXECUTION_TIMES\ndeclare -A SCRIPT_FAILURE_COUNTS\ndeclare -A SYSTEM_LOAD_VALUES\n\n# Cache TTL (Time To Live) in seconds\nCACHE_TTL=30\nLAST_CACHE_UPDATE=0\n\n# Performance configuration functions\nfunction get_performance_config() {\n  local key=\"$1\"\n  local default=\"$2\"\n  get_config_value \"performance.$key\" \"$default\"\n}\n\nfunction is_performance_monitoring_enabled() {\n  get_performance_config \"enable_monitoring\" \"true\"\n}\n\nfunction get_load_threshold() {\n  get_performance_config \"load_threshold\" \"0.8\"\n}\n\nfunction get_cache_ttl() {\n  get_performance_config \"cache_ttl\" \"30\"\n}\n\nfunction is_scheduling_optimized() {\n  get_performance_config \"optimize_scheduling\" \"true\"\n}\n\n# System load monitoring\nfunction get_system_load() {\n  if [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n    # macOS: use sysctl\n    sysctl -n vm.loadavg | awk '{print $1}'\n  else\n    # Linux: use /proc/loadavg\n    cat /proc/loadavg | cut -d' ' -f1\n  fi\n}\n\nfunction get_cpu_cores() {\n  if [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n    sysctl -n hw.ncpu\n  else\n    nproc\n  fi\n}\n\nfunction is_system_overloaded() {\n  if ! is_performance_monitoring_enabled; then\n    return 1\n  fi\n  \n  local load=$(get_system_load)\n  local cores=$(get_cpu_cores)\n  local threshold=$(get_load_threshold)\n  local max_load=$(echo \"$cores * $threshold\" | bc -l)\n  \n  if (( $(echo \"$load > $max_load\" | bc -l) )); then\n    log_warn \"System load is high: $load (threshold: $max_load)\"\n    return 0  # true, system is overloaded\n  fi\n  return 1  # false, system is not overloaded\n}\n\n# Resource monitoring\nfunction get_memory_usage() {\n  if [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n    # macOS: use vm_stat\n    vm_stat | grep \"Pages free\" | awk '{print $3}' | sed 's/\\.//'\n  else\n    # Linux: use /proc/meminfo\n    free | grep Mem | awk '{print $3/$2 * 100.0}'\n  fi\n}\n\nfunction get_disk_usage() {\n  df -h / | awk 'NR==2 {print $5}' | sed 's/%//'\n}\n\n# Concurrent execution management\nfunction count_running_scripts() {\n  local count=0\n  local pid_file=$(get_pid_file)\n  \n  if [[ -f \"$pid_file\" ]]; then\n    local daemon_pid=$(cat \"$pid_file\")\n    if kill -0 \"$daemon_pid\" 2>/dev/null; then\n      count=$(pgrep -P \"$daemon_pid\" | wc -l)\n    fi\n  fi\n  \n  echo \"$count\"\n}\n\nfunction can_run_more_scripts() {\n  local max_concurrent=$(get_max_concurrent)\n  local running=$(count_running_scripts)\n  \n  if [[ $running -ge $max_concurrent ]]; then\n    log_debug \"At max concurrent capacity: $running/$max_concurrent\"\n    return 1  # false, at max capacity\n  fi\n  \n  # Check system load\n  if is_system_overloaded; then\n    return 1  # false, system is overloaded\n  fi\n  \n  return 0  # true, can run more scripts\n}\n\n# Caching system using associative arrays\nfunction get_cached_value() {\n  local key=\"$1\"\n  local current_time=$(date +%s)\n  \n  if [[ -n \"${PERFORMANCE_CACHE[$key]}\" ]]; then\n    local cached_time=\"${PERFORMANCE_CACHE_TIMES[$key]}\"\n    local age=$((current_time - cached_time))\n    \n    if [[ $age -lt $CACHE_TTL ]]; then\n      echo \"${PERFORMANCE_CACHE[$key]}\"\n      return 0\n    fi\n  fi\n  \n  return 1\n}\n\nfunction set_cached_value() {\n  local key=\"$1\"\n  local value=\"$2\"\n  local current_time=$(date +%s)\n  \n  PERFORMANCE_CACHE[$key]=\"$value\"\n  PERFORMANCE_CACHE_TIMES[$key]=\"$current_time\"\n}\n\n# Script execution tracking using associative arrays\nfunction track_script_execution() {\n  local script_name=\"$1\"\n  local execution_time=\"$2\"\n  local success=\"$3\"\n  \n  SCRIPT_EXECUTION_TIMES[$script_name]=\"$execution_time\"\n  \n  if [[ \"$success\" == \"false\" ]]; then\n    SCRIPT_FAILURE_COUNTS[$script_name]=$((${SCRIPT_FAILURE_COUNTS[$script_name]:-0} + 1))\n  fi\n}\n\nfunction get_script_avg_execution_time() {\n  local script_name=\"$1\"\n  echo \"${SCRIPT_EXECUTION_TIMES[$script_name]:-0}\"\n}\n\nfunction get_script_failure_count() {\n  local script_name=\"$1\"\n  echo \"${SCRIPT_FAILURE_COUNTS[$script_name]:-0}\"\n}\n\n# Optimized script scheduling\nfunction optimize_schedule() {\n  if ! is_scheduling_optimized; then\n    get_enabled_scripts\n    return\n  fi\n  \n  # Get all enabled scripts with their intervals and execution times\n  local scripts_info=()\n  \n  while IFS= read -r script_name; do\n    local interval=$(get_script_interval \"$script_name\")\n    local avg_time=$(get_script_avg_execution_time \"$script_name\")\n    local failures=$(get_script_failure_count \"$script_name\")\n    \n    # Calculate priority score (lower is better)\n    # Prioritize: shorter intervals, faster execution, fewer failures\n    local priority_score=$(echo \"$interval + $avg_time - ($failures * 10)\" | bc -l)\n    \n    scripts_info+=(\"$priority_score:$script_name\")\n  done < <(get_enabled_scripts)\n  \n  # Sort by priority score and return script names\n  printf '%s\\n' \"${scripts_info[@]}\" | sort -n | cut -d: -f2\n}\n\n# Performance metrics collection\nfunction collect_performance_metrics() {\n  local metrics=()\n  \n  metrics+=(\"load:$(get_system_load)\")\n  metrics+=(\"memory:$(get_memory_usage)\")\n  metrics+=(\"disk:$(get_disk_usage)\")\n  metrics+=(\"running_scripts:$(count_running_scripts)\")\n  metrics+=(\"max_concurrent:$(get_max_concurrent)\")\n  \n  printf '%s\\n' \"${metrics[@]}\"\n}\n\n# Performance report\nfunction generate_performance_report() {\n  echo \"=== BAMON Performance Report ===\"\n  echo \"Timestamp: $(date)\"\n  echo \"\"\n  \n  echo \"System Metrics:\"\n  collect_performance_metrics | while IFS=: read -r metric value; do\n    echo \"  $metric: $value\"\n  done\n  echo \"\"\n  \n  echo \"Script Performance:\"\n  for script_name in $(get_enabled_scripts); do\n    local avg_time=$(get_script_avg_execution_time \"$script_name\")\n    local failures=$(get_script_failure_count \"$script_name\")\n    echo \"  $script_name: avg_time=${avg_time}s, failures=$failures\"\n  done\n  echo \"\"\n  \n  echo \"Cache Status:\"\n  echo \"  Cache TTL: ${CACHE_TTL}s\"\n  echo \"  Cached items: ${#PERFORMANCE_CACHE[@]}\"\n}\n\n# Cleanup old cache entries\nfunction cleanup_cache() {\n  local current_time=$(date +%s)\n  \n  for key in \"${!PERFORMANCE_CACHE[@]}\"; do\n    local cached_time=\"${PERFORMANCE_CACHE_TIMES[$key]}\"\n    local age=$((current_time - cached_time))\n    \n    if [[ $age -gt $CACHE_TTL ]]; then\n      unset PERFORMANCE_CACHE[$key]\n      unset PERFORMANCE_CACHE_TIMES[$key]\n    fi\n  done\n}\n```\n2. Add performance configuration functions to `src/lib/config.sh`\n3. Integrate performance monitoring into `src/lib/execution.sh`\n4. Add performance CLI command to show metrics\n5. Implement efficient file operations and caching\n6. Add system resource monitoring and adaptive scheduling\n7. Use modern Bash 4.0+ features like associative arrays for better performance\n8. Use portable syntax for cross-platform compatibility between macOS and Linux\n9. Use bc for all floating-point calculations to ensure compatibility\n10. Verify integration with the logging library (src/lib/logging.sh)",
        "testStrategy": "1. Test performance monitoring under various system loads\n2. Verify caching improves performance for frequent operations\n3. Test concurrent execution limits with resource monitoring\n4. Measure and validate performance metrics collection\n5. Test adaptive scheduling with different script configurations\n6. Verify performance report generation and accuracy\n7. Test compatibility with Bash 4.0+ on macOS (system default or Homebrew)\n8. Test compatibility with newer Bash versions (4.2+, 5.3.3) on Linux\n9. Verify proper integration with the logging system\n10. Test error handling when performance functions are called\n11. Test sandbox timeout configuration with the fixed sandbox.sh implementation\n12. Verify performance optimization with modern Bash features\n13. Test with both system default bash and Homebrew bash on macOS",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement associative arrays for performance monitoring",
            "description": "Use Bash 4.0+ associative arrays for efficient key-value storage in the performance monitoring system",
            "status": "done",
            "dependencies": [],
            "details": "1. Replace parallel array implementation with proper associative arrays\n2. Use declare -A for all key-value data structures\n3. Update all functions to use associative array syntax\n4. Optimize lookup operations using direct key access\n<info added on 2025-09-13T16:41:35.608Z>\n✅ Successfully implemented associative arrays for performance monitoring!\n\n**Key Changes Made:**\n1. **Replaced parallel arrays with associative arrays**: Converted from Bash 3.2 compatible parallel arrays to modern Bash 4.0+ associative arrays\n2. **Updated variable declarations**: Changed from `PERFORMANCE_CACHE_KEYS=()` to `declare -A PERFORMANCE_CACHE`\n3. **Simplified caching functions**: \n   - `get_cached_value()`: Now uses direct key access `${PERFORMANCE_CACHE[$key]}` instead of array iteration\n   - `set_cached_value()`: Now uses direct assignment instead of complex array management\n4. **Optimized script tracking**: \n   - `track_script_execution()`: Simplified to direct associative array operations\n   - `get_script_avg_execution_time()`: Now uses `${SCRIPT_EXECUTION_TIMES[$script_name]:-0}`\n   - `get_script_failure_count()`: Now uses `${SCRIPT_FAILURE_COUNTS[$script_name]:-0}`\n5. **Improved cache cleanup**: `cleanup_cache()` now iterates over associative array keys directly\n\n**Performance Improvements:**\n- **O(1) lookup time** instead of O(n) for cache and script data access\n- **Simplified code** with fewer lines and better readability\n- **Direct key access** eliminates need for array iteration and searching\n- **Memory efficient** with proper associative array management\n\n**Testing Results:**\n- ✅ Caching system works correctly (stored and retrieved test values)\n- ✅ Script execution tracking works (tracked execution times and failure counts)\n- ✅ Performance report generation works with new associative arrays\n- ✅ Cache status correctly shows number of cached items\n- ✅ All functions use modern Bash 4.0+ syntax\n\n**Integration Status:**\n- ✅ Functions are already integrated with execution system via `track_script_execution()` calls\n- ✅ Performance command works correctly with new implementation\n- ✅ No breaking changes to existing functionality\n</info added on 2025-09-13T16:41:35.608Z>",
            "testStrategy": "1. Test associative array performance with various data sizes\n2. Verify correct key-value storage and retrieval\n3. Test with different Bash versions (4.0+)\n4. Compare performance against previous implementation"
          },
          {
            "id": 2,
            "title": "Implement efficient caching system",
            "description": "Create functions to store and retrieve cached values using associative arrays for optimal performance",
            "status": "done",
            "dependencies": [],
            "details": "1. Use associative arrays for the caching system\n2. Implement TTL (Time To Live) functionality\n3. Create efficient cache cleanup mechanism\n4. Add cache statistics tracking\n<info added on 2025-09-13T17:30:50.948Z>\n1. **Cache Statistics Tracking Implementation**:\n   - Added global variables: `CACHE_HITS=0`, `CACHE_MISSES=0`, `CACHE_EVICTIONS=0`, `CACHE_SIZE=0`\n   - Implemented `get_cache_hit_rate()` function that calculates percentage using bc\n\n2. **Enhanced Cache Functions**:\n   - Modified `get_cached_value()` to track hits/misses and remove expired entries\n   - Updated `set_cached_value()` to track new keys and enforce size limits\n   - Improved `cleanup_cache()` to track evictions and maintain accurate size counts\n\n3. **Cache Size Management**:\n   - Implemented `MAX_CACHE_SIZE=1000` configuration parameter\n   - Created `enforce_cache_size_limit()` function with LRU eviction strategy\n   - Added automatic size limit enforcement on every cache write operation\n\n4. **Cache Statistics Functions**:\n   - Implemented `get_cache_stats()` for comprehensive statistics display\n   - Created `reset_cache_stats()` to reset all statistics for testing purposes\n\n5. **Performance Report Integration**:\n   - Added cache performance metrics to `bamon performance` command output\n   - Integrated real-time cache statistics into performance reporting\n\n6. **Performance Testing Results**:\n   - Cache hit rate testing: 75% hit rate (3 hits, 1 miss)\n   - Size limit enforcement: Successfully evicted 3 entries when limit set to 2\n   - Statistics tracking: All counters function correctly\n   - TTL functionality: Cache entries expire properly based on configured TTL\n</info added on 2025-09-13T17:30:50.948Z>",
            "testStrategy": "1. Test cache hit/miss rates\n2. Verify TTL functionality works correctly\n3. Test cache cleanup performance\n4. Measure performance improvement from caching"
          },
          {
            "id": 3,
            "title": "Verify logging integration",
            "description": "Ensure performance library properly integrates with the logging library and uses appropriate log levels",
            "status": "in-progress",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Test with Bash 4.0+ versions",
            "description": "Verify the performance library works correctly with Bash 4.0+ on different platforms",
            "status": "not-started",
            "dependencies": [],
            "details": "1. Test with system default bash on macOS (if 4.0+)\n2. Test with Homebrew bash on macOS\n3. Test with modern bash on Linux\n4. Verify all features work consistently across all bash versions\n5. Utilize Bash 4.0+ features for optimal performance",
            "testStrategy": "1. Create test scripts that exercise all performance functions\n2. Run tests with explicit bash version specification\n3. Verify output is consistent across all bash versions\n4. Check for any syntax errors or compatibility issues\n5. Measure performance to ensure optimal speed with modern Bash features"
          },
          {
            "id": 5,
            "title": "Update performance CLI command",
            "description": "Ensure the performance command works with the refactored library and displays metrics correctly",
            "status": "not-started",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Integrate with fixed sandbox timeout configuration",
            "description": "Ensure performance monitoring works correctly with the fixed sandbox timeout configuration in execute_sandboxed_from_config function",
            "status": "not-started",
            "dependencies": [],
            "details": "1. Verify that performance monitoring correctly tracks script execution with the fixed sandbox timeout\n2. Update performance metrics to include timeout information\n3. Test with scripts that should timeout after 3 seconds as configured in config.yaml",
            "testStrategy": "1. Run long-running scripts and verify they timeout after 3 seconds\n2. Check that performance metrics correctly record timeouts\n3. Verify that the performance report includes timeout information"
          },
          {
            "id": 7,
            "title": "Test performance with sandbox timeout configuration",
            "description": "Test performance optimization with the fixed sandbox timeout configuration to ensure proper resource management",
            "status": "not-started",
            "dependencies": [
              6
            ],
            "details": "1. Test performance with various timeout configurations\n2. Verify that performance monitoring correctly adapts to different timeout settings\n3. Ensure that resource management works correctly with timed-out scripts",
            "testStrategy": "1. Configure different timeout values and measure performance impact\n2. Test with scripts that timeout and verify resource cleanup\n3. Verify that performance metrics are accurate for timed-out scripts"
          },
          {
            "id": 8,
            "title": "Optimize date operations for performance",
            "description": "Implement efficient date operations using modern Bash features for better performance",
            "status": "not-started",
            "dependencies": [],
            "details": "1. Use modern date command features for timestamp generation\n2. Optimize date arithmetic operations for cache TTL calculations\n3. Implement efficient time-based operations for performance metrics\n4. Use built-in Bash arithmetic where possible instead of external commands",
            "testStrategy": "1. Test date functions on both macOS and Linux\n2. Verify timestamp generation is consistent\n3. Test cache TTL calculations for accuracy\n4. Measure performance of date operations"
          },
          {
            "id": 9,
            "title": "Optimize associative array operations",
            "description": "Optimize associative array operations for maximum performance",
            "status": "not-started",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Benchmark associative array performance\n2. Optimize key access patterns\n3. Implement efficient iteration over associative arrays\n4. Optimize memory usage for large datasets",
            "testStrategy": "1. Benchmark lookup performance with various array sizes\n2. Test with realistic workloads to ensure acceptable performance\n3. Verify optimizations maintain compatibility with Bash 4.0+\n4. Compare performance against alternative implementations"
          },
          {
            "id": 10,
            "title": "Implement advanced performance metrics",
            "description": "Add advanced performance metrics collection using modern Bash capabilities",
            "status": "not-started",
            "dependencies": [
              1
            ],
            "details": "1. Add detailed CPU utilization metrics\n2. Implement memory usage tracking per script\n3. Add disk I/O monitoring\n4. Create network usage metrics if applicable\n5. Implement trend analysis for performance over time",
            "testStrategy": "1. Test metrics collection under various system loads\n2. Verify accuracy of collected metrics\n3. Test performance impact of metrics collection\n4. Verify metrics visualization in CLI reports"
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement Status Check Command",
        "description": "Create a command to check the last execution status of all scripts without running them, showing execution history and scheduled information.",
        "details": "1. Create `src/status_check_command.sh` to implement the status check functionality:\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\nsource \"${BASH_SOURCE%/*}/lib/logger.sh\"\n\nfunction status_check_command() {\n  local name=${args[--name]}\n  local json_output=${args[--json]}\n  \n  # Load config\n  load_config\n  \n  # Get all scripts or specific script\n  local scripts=\"\"\n  if [[ -n \"$name\" ]]; then\n    if ! script_exists \"$name\"; then\n      echo \"Error: Script '$name' does not exist\"\n      return 1\n    fi\n    scripts=\"$name\"\n  else\n    scripts=$(get_all_scripts)\n    if [[ -z \"$scripts\" ]]; then\n      echo \"No scripts configured. Use 'bamon add' to add scripts.\"\n      return 0\n    fi\n  fi\n  \n  # Print header if not JSON output\n  if [[ \"$json_output\" != \"true\" ]]; then\n    printf \"%-20s %-20s %-10s %-15s %-20s %-20s %s\\n\" \"NAME\" \"LAST EXECUTION\" \"RESULT\" \"DURATION\" \"TIME SINCE\" \"NEXT EXECUTION\" \"ERROR\"\n    printf \"%s\\n\" \"$(printf '=%.0s' {1..120})\"\n  else\n    echo \"{\"\n    echo \"  \\\"scripts\\\": [\"\n  fi\n  \n  local first=true\n  for script in $scripts; do\n    # Get script details\n    local enabled=$(get_script_property \"$script\" \"enabled\")\n    local last_run=$(get_script_property \"$script\" \"last_run\")\n    local last_status=$(get_script_property \"$script\" \"last_status\")\n    local last_duration=$(get_script_property \"$script\" \"last_duration\")\n    local last_error=$(get_script_property \"$script\" \"last_error\")\n    local interval=$(get_script_property \"$script\" \"interval\")\n    \n    # Calculate time since last execution\n    local time_since=\"Never\"\n    if [[ -n \"$last_run\" && \"$last_run\" != \"null\" ]]; then\n      local now=$(date +%s)\n      local last_run_seconds=$(date -d \"$last_run\" +%s 2>/dev/null || date -j -f \"%Y-%m-%d %H:%M:%S\" \"$last_run\" +%s 2>/dev/null)\n      local seconds_diff=$((now - last_run_seconds))\n      \n      if [[ $seconds_diff -lt 60 ]]; then\n        time_since=\"${seconds_diff}s ago\"\n      elif [[ $seconds_diff -lt 3600 ]]; then\n        time_since=\"$((seconds_diff / 60))m ago\"\n      elif [[ $seconds_diff -lt 86400 ]]; then\n        time_since=\"$((seconds_diff / 3600))h ago\"\n      else\n        time_since=\"$((seconds_diff / 86400))d ago\"\n      fi\n    fi\n    \n    # Calculate next execution time\n    local next_execution=\"Not scheduled\"\n    if [[ \"$enabled\" == \"true\" && -n \"$last_run\" && \"$last_run\" != \"null\" && -n \"$interval\" ]]; then\n      # Parse interval (e.g., 1h, 30m, 1d)\n      local interval_value=${interval%[hmd]*}\n      local interval_unit=${interval#$interval_value}\n      \n      local seconds_to_add=0\n      case \"$interval_unit\" in\n        m) seconds_to_add=$((interval_value * 60)) ;;\n        h) seconds_to_add=$((interval_value * 3600)) ;;\n        d) seconds_to_add=$((interval_value * 86400)) ;;\n      esac\n      \n      local next_run_seconds=$((last_run_seconds + seconds_to_add))\n      local next_run_date=$(date -d \"@$next_run_seconds\" \"+%Y-%m-%d %H:%M:%S\" 2>/dev/null || date -r \"$next_run_seconds\" \"+%Y-%m-%d %H:%M:%S\" 2>/dev/null)\n      \n      # Check if next execution is in the past or future\n      if [[ $next_run_seconds -lt $now ]]; then\n        next_execution=\"Overdue (${next_run_date})\"\n      else\n        local time_until=$((next_run_seconds - now))\n        if [[ $time_until -lt 60 ]]; then\n          next_execution=\"In ${time_until}s\"\n        elif [[ $time_until -lt 3600 ]]; then\n          next_execution=\"In $((time_until / 60))m\"\n        elif [[ $time_until -lt 86400 ]]; then\n          next_execution=\"In $((time_until / 3600))h\"\n        else\n          next_execution=\"In $((time_until / 86400))d\"\n        fi\n      fi\n    elif [[ \"$enabled\" != \"true\" ]]; then\n      next_execution=\"Disabled\"\n    fi\n    \n    # Format result\n    local result=\"Unknown\"\n    if [[ -n \"$last_status\" ]]; then\n      if [[ \"$last_status\" == \"0\" ]]; then\n        result=\"Success\"\n      else\n        result=\"Failed\"\n      fi\n    fi\n    \n    # Format duration\n    local duration=\"N/A\"\n    if [[ -n \"$last_duration\" && \"$last_duration\" != \"null\" ]]; then\n      if [[ $last_duration -lt 1 ]]; then\n        duration=\"<1s\"\n      elif [[ $last_duration -lt 60 ]]; then\n        duration=\"${last_duration}s\"\n      elif [[ $last_duration -lt 3600 ]]; then\n        duration=\"$((last_duration / 60))m $((last_duration % 60))s\"\n      else\n        duration=\"$((last_duration / 3600))h $((last_duration / 60 % 60))m\"\n      fi\n    fi\n    \n    # Truncate error message if too long\n    local error_msg=\"\"\n    if [[ -n \"$last_error\" && \"$last_error\" != \"null\" ]]; then\n      if [[ ${#last_error} -gt 30 ]]; then\n        error_msg=\"${last_error:0:27}...\"\n      else\n        error_msg=\"$last_error\"\n      fi\n    fi\n    \n    # Output in requested format\n    if [[ \"$json_output\" == \"true\" ]]; then\n      if [[ \"$first\" != \"true\" ]]; then\n        echo \"    ,\"\n      fi\n      first=false\n      \n      echo \"    {\"\n      echo \"      \\\"name\\\": \\\"$script\\\",\"\n      echo \"      \\\"lastExecution\\\": \\\"${last_run:-null}\\\",\"\n      echo \"      \\\"result\\\": \\\"$result\\\",\"\n      echo \"      \\\"duration\\\": \\\"$duration\\\",\"\n      echo \"      \\\"timeSince\\\": \\\"$time_since\\\",\"\n      echo \"      \\\"nextExecution\\\": \\\"$next_execution\\\",\"\n      echo \"      \\\"error\\\": \\\"${last_error:-null}\\\"\"\n      echo -n \"    }\"\n    else\n      printf \"%-20s %-20s %-10s %-15s %-20s %-20s %s\\n\" \\\n        \"$script\" \\\n        \"${last_run:-Never}\" \\\n        \"$result\" \\\n        \"$duration\" \\\n        \"$time_since\" \\\n        \"$next_execution\" \\\n        \"$error_msg\"\n    fi\n  done\n  \n  if [[ \"$json_output\" == \"true\" ]]; then\n    echo \"\"\n    echo \"  ]\"\n    echo \"}\"\n  fi\n}\n```\n\n2. Update `src/main.sh` to include the new command:\n```bash\n# Add to the command list\ncommands[\"status-check\"]=\"Check the last execution status of all scripts without running them\"\n\n# Add to the command handler\nelif [[ \"$command\" == \"status-check\" ]]; then\n  source \"${BASH_SOURCE%/*}/status_check_command.sh\"\n  status_check_command\n```\n\n3. Add command-line options in the help text:\n```bash\n  status-check [--name SCRIPT_NAME] [--json]\n    Check the last execution status of all scripts without running them\n    Options:\n      --name SCRIPT_NAME  Check status of a specific script\n      --json              Output in JSON format\n```\n\n4. Ensure the status check command reads from the execution history stored in the configuration file, without triggering any new executions.\n\n5. Implement proper error handling for cases where scripts have never been executed or where execution data is incomplete.\n\n6. Add cross-platform compatibility for date calculations to ensure the command works on both Linux and macOS.",
        "testStrategy": "1. Test status check command with no scripts configured:\n   - Verify appropriate message is displayed\n   - Check exit code is 0\n\n2. Test with multiple scripts in different states:\n   - Scripts that have never run\n   - Scripts that succeeded in their last run\n   - Scripts that failed in their last run\n   - Disabled scripts\n   - Scripts with different interval settings\n\n3. Test filtering for a specific script:\n   - Verify correct output when script exists\n   - Verify error handling when script doesn't exist\n\n4. Test JSON output format:\n   - Ensure valid JSON is produced\n   - Verify all fields are correctly populated\n   - Test with both single script and multiple scripts\n\n5. Verify time calculations:\n   - Test with scripts run at different times (just now, minutes ago, hours ago, days ago)\n   - Verify \"time since last execution\" is calculated correctly\n   - Verify \"next scheduled execution\" is calculated correctly for different intervals\n\n6. Test cross-platform compatibility:\n   - Verify the command works correctly on both Linux and macOS\n   - Test date calculations on both platforms\n\n7. Test with edge cases:\n   - Scripts with very long error messages\n   - Scripts with extremely short or long execution durations\n   - Scripts with unusual interval settings",
        "status": "pending",
        "dependencies": [
          2,
          5,
          10
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement core status check functionality",
            "description": "Create the main status_check_command function that retrieves execution status for all scripts or a specific script",
            "dependencies": [],
            "details": "Implement the core functionality in src/status_check_command.sh that loads configuration, retrieves script execution data, and handles the --name parameter to filter for a specific script. Include proper error handling for non-existent scripts and empty script lists.",
            "status": "pending",
            "testStrategy": "Test with no scripts configured, with a single script, and with multiple scripts. Verify proper error handling when a non-existent script is specified."
          },
          {
            "id": 2,
            "title": "Implement status formatting and display logic",
            "description": "Create the formatting logic for displaying script execution status in both human-readable and JSON formats",
            "dependencies": [
              "15.1"
            ],
            "details": "Implement the display logic that formats execution status information including last execution time, result (success/failure), duration, time since last run, next scheduled execution, and error messages. Support both human-readable tabular output and structured JSON output based on the --json flag.",
            "status": "pending",
            "testStrategy": "Test both output formats with various script states. Verify proper formatting of durations, timestamps, and error messages. Test truncation of long error messages."
          },
          {
            "id": 3,
            "title": "Implement time calculation functions",
            "description": "Create cross-platform compatible functions for date/time calculations to determine time since last run and next execution",
            "dependencies": [
              "15.1"
            ],
            "details": "Implement functions that calculate time differences and format them in a human-readable way (e.g., '5m ago', 'In 2h'). Ensure compatibility with both Linux (date -d) and macOS (date -j) date commands. Handle edge cases like scripts that have never run or are disabled.",
            "status": "pending",
            "testStrategy": "Test on both Linux and macOS platforms. Verify correct calculations for various time intervals (seconds, minutes, hours, days). Test edge cases like never-run scripts and disabled scripts."
          },
          {
            "id": 4,
            "title": "Integrate status check command with main CLI",
            "description": "Update src/main.sh to include the new status-check command and its help text",
            "dependencies": [
              "15.1",
              "15.2"
            ],
            "details": "Add the status-check command to the commands array in src/main.sh. Include the command in the help text with proper documentation of the --name and --json options. Update the command handler to source the status_check_command.sh file and call the status_check_command function.",
            "status": "pending",
            "testStrategy": "Test the help command to verify the status-check command is properly documented. Test command invocation through the main CLI with various parameters."
          },
          {
            "id": 5,
            "title": "Implement Enhanced Status Check Command with JSON Support",
            "description": "Create a comprehensive status check command that displays detailed execution results for all monitored scripts with support for JSON output format, filtering options, and execution history storage.",
            "status": "pending",
            "dependencies": [
              5,
              3,
              4
            ],
            "details": "1. Extend the existing status command in `src/status_command.sh` to include detailed execution information:\n\n```bash\n#!/usr/bin/env bash\n\nsource \"${BASH_SOURCE%/*}/lib/config.sh\"\nsource \"${BASH_SOURCE%/*}/lib/logger.sh\"\n\nfunction status_command() {\n  local verbose=${args[--verbose]}\n  local failed_only=${args[--failed-only]}\n  local json_output=${args[--json]}\n  local history_file=$(get_history_file_path)\n  \n  # Load config\n  load_config\n  \n  # Prepare data structure for output\n  declare -A status_data\n  status_data[\"daemon_status\"]=$(is_daemon_running && echo \"RUNNING\" || echo \"STOPPED\")\n  \n  if is_daemon_running; then\n    status_data[\"daemon_pid\"]=$(cat \"$(get_pid_file)\")\n  fi\n  \n  # Get all scripts\n  local scripts=$(get_all_scripts)\n  \n  # Prepare scripts array\n  declare -a script_entries\n  \n  # Process each script\n  for script in $scripts; do\n    local enabled=$(is_script_enabled \"$script\" && echo \"true\" || echo \"false\")\n    local last_run=$(get_script_last_run \"$script\")\n    local last_status=$(get_script_last_status \"$script\")\n    local exit_code=$(get_script_exit_code \"$script\")\n    local execution_time=$(get_script_execution_time \"$script\")\n    local stdout=$(get_script_stdout \"$script\")\n    local stderr=$(get_script_stderr \"$script\")\n    \n    # Skip if failed_only is set and script didn't fail\n    if [[ \"$failed_only\" == \"true\" && \"$last_status\" != \"FAILED\" ]]; then\n      continue\n    fi\n    \n    # Create script entry\n    local script_entry=$(create_script_entry \"$script\" \"$enabled\" \"$last_run\" \"$last_status\" \"$exit_code\" \"$execution_time\" \"$stdout\" \"$stderr\")\n    script_entries+=(\"$script_entry\")\n  done\n  \n  # Output in requested format\n  if [[ \"$json_output\" == \"true\" ]]; then\n    output_json_format \"$(get_daemon_status)\" \"${script_entries[@]}\"\n  else\n    output_text_format \"$(get_daemon_status)\" \"${script_entries[@]}\" \"$verbose\"\n  fi\n  \n  # Store execution history\n  store_execution_history \"${script_entries[@]}\"\n  \n  return 0\n}\n\n# Create a structured script entry\nfunction create_script_entry() {\n  local script=$1\n  local enabled=$2\n  local last_run=$3\n  local last_status=$4\n  local exit_code=$5\n  local execution_time=$6\n  local stdout=$7\n  local stderr=$8\n  \n  # Create JSON-like structure\n  echo \"{\\\"name\\\":\\\"$script\\\",\\\"enabled\\\":$enabled,\\\"last_run\\\":\\\"$last_run\\\",\\\"status\\\":\\\"$last_status\\\",\\\"exit_code\\\":$exit_code,\\\"execution_time\\\":$execution_time,\\\"stdout\\\":\\\"$(escape_json \"$stdout\")\\\",\\\"stderr\\\":\\\"$(escape_json \"$stderr\")\\\"}\"\n}\n\n# Escape special characters for JSON\nfunction escape_json() {\n  local text=$1\n  echo \"$text\" | sed 's/\\\\/\\\\\\\\/g' | sed 's/\"/\\\\\"/g' | sed 's/\\n/\\\\n/g' | sed 's/\\t/\\\\t/g'\n}\n\n# Output in JSON format\nfunction output_json_format() {\n  local daemon_status=$1\n  shift\n  local script_entries=(\"$@\")\n  \n  # Start JSON output\n  echo \"{\"\n  echo \"  \\\"daemon\\\": {\"\n  echo \"    \\\"status\\\": \\\"$daemon_status\\\"\"\n  if [[ \"$daemon_status\" == \"RUNNING\" ]]; then\n    echo \"    ,\\\"pid\\\": $(cat \"$(get_pid_file)\")\"\n  fi\n  echo \"  },\"\n  echo \"  \\\"scripts\\\": [\"\n  \n  # Add script entries\n  local first=true\n  for entry in \"${script_entries[@]}\"; do\n    if [[ \"$first\" == \"true\" ]]; then\n      first=false\n    else\n      echo \",\"\n    fi\n    echo \"    $entry\"\n  done\n  \n  # Close JSON\n  echo \"  ]\"\n  echo \"}\"\n}\n\n# Output in text format\nfunction output_text_format() {\n  local daemon_status=$1\n  shift\n  local script_entries=(\"$@\")\n  local verbose=$1\n  \n  # Print daemon status\n  echo \"Daemon: $daemon_status\"\n  if [[ \"$daemon_status\" == \"RUNNING\" ]]; then\n    echo \"PID: $(cat \"$(get_pid_file)\")\"\n  fi\n  echo \"\"\n  \n  # Print script status\n  if [[ ${#script_entries[@]} -eq 0 ]]; then\n    echo \"No scripts configured or matching filter criteria.\"\n    return\n  fi\n  \n  echo \"Scripts:\"\n  printf \"%-20s %-10s %-20s %-10s %-10s\\n\" \"NAME\" \"STATUS\" \"LAST RUN\" \"EXIT CODE\" \"DURATION\"\n  echo \"--------------------------------------------------------------------------------\"\n  \n  for entry in \"${script_entries[@]}\"; do\n    # Parse entry\n    local name=$(echo \"$entry\" | jq -r '.name')\n    local status=$(echo \"$entry\" | jq -r '.status')\n    local last_run=$(echo \"$entry\" | jq -r '.last_run')\n    local exit_code=$(echo \"$entry\" | jq -r '.exit_code')\n    local execution_time=$(echo \"$entry\" | jq -r '.execution_time')\n    \n    printf \"%-20s %-10s %-20s %-10s %-10s\\n\" \"$name\" \"$status\" \"$last_run\" \"$exit_code\" \"${execution_time}s\"\n    \n    # Show stdout/stderr if verbose\n    if [[ \"$verbose\" == \"true\" ]]; then\n      local stdout=$(echo \"$entry\" | jq -r '.stdout')\n      local stderr=$(echo \"$entry\" | jq -r '.stderr')\n      \n      if [[ -n \"$stdout\" ]]; then\n        echo \"  STDOUT:\"\n        echo \"    $stdout\" | sed 's/^/    /'\n      fi\n      \n      if [[ -n \"$stderr\" ]]; then\n        echo \"  STDERR:\"\n        echo \"    $stderr\" | sed 's/^/    /'\n      fi\n      \n      echo \"\"\n    fi\n  done\n}\n\n# Get history file path from config\nfunction get_history_file_path() {\n  local history_file=$(yq e '.daemon.history_file' \"$CONFIG_FILE\")\n  echo \"${history_file/#~/$HOME}\"\n}\n\n# Store execution history\nfunction store_execution_history() {\n  local script_entries=(\"$@\")\n  local history_file=$(get_history_file_path)\n  local history_dir=$(dirname \"$history_file\")\n  local retention_days=$(yq e '.daemon.history_retention_days // 30' \"$CONFIG_FILE\")\n  \n  # Create directory if it doesn't exist\n  if [[ ! -d \"$history_dir\" ]]; then\n    mkdir -p \"$history_dir\"\n  fi\n  \n  # Create history file if it doesn't exist\n  if [[ ! -f \"$history_file\" ]]; then\n    echo \"[]\" > \"$history_file\"\n  fi\n  \n  # Read existing history\n  local history=$(cat \"$history_file\")\n  \n  # Add new entries\n  local timestamp=$(date +%s)\n  for entry in \"${script_entries[@]}\"; do\n    # Add timestamp to entry\n    entry=$(echo \"$entry\" | jq --arg ts \"$timestamp\" '. + {timestamp: $ts|tonumber}')\n    \n    # Add to history\n    history=$(echo \"$history\" | jq --argjson entry \"$entry\" '. += [$entry]')\n  done\n  \n  # Prune old entries\n  local cutoff=$(($(date +%s) - retention_days * 86400))\n  history=$(echo \"$history\" | jq --arg cutoff \"$cutoff\" '[.[] | select(.timestamp >= ($cutoff|tonumber))]')\n  \n  # Write back to file\n  echo \"$history\" > \"$history_file\"\n}\n\n# Add configuration options to config.sh\n# In src/lib/config.sh, add:\n# - history_file: ~/.bamon/history.json\n# - history_retention_days: 30\n```\n\n2. Update the main CLI parser in `src/bamon.sh` to support the new command-line options:\n```bash\n# Add to the existing options for status command:\n--json)\n  args[--json]=true\n  ;;\n```\n\n3. Add configuration options to the default configuration template in `src/lib/config.sh`:\n```bash\n# Default configuration\nDEFAULT_CONFIG=$(cat <<EOF\ndaemon:\n  pid_file: ~/.bamon/bamon.pid\n  log_file: ~/.bamon/bamon.log\n  history_file: ~/.bamon/history.json\n  history_retention_days: 30\nEOF\n)\n```\n\n4. Implement functions to retrieve script execution details in `src/lib/config.sh`:\n```bash\n# Get script last run timestamp\nfunction get_script_last_run() {\n  local script=$1\n  local timestamp=$(yq e \".scripts.$script.last_run\" \"$CONFIG_FILE\")\n  \n  if [[ \"$timestamp\" == \"null\" ]]; then\n    echo \"Never\"\n  else\n    date -r \"$timestamp\" \"+%Y-%m-%d %H:%M:%S\"\n  fi\n}\n\n# Get script last status\nfunction get_script_last_status() {\n  local script=$1\n  local status=$(yq e \".scripts.$script.last_status\" \"$CONFIG_FILE\")\n  \n  if [[ \"$status\" == \"null\" ]]; then\n    echo \"UNKNOWN\"\n  else\n    echo \"$status\"\n  fi\n}\n\n# Get script exit code\nfunction get_script_exit_code() {\n  local script=$1\n  local exit_code=$(yq e \".scripts.$script.exit_code\" \"$CONFIG_FILE\")\n  \n  if [[ \"$exit_code\" == \"null\" ]]; then\n    echo \"-\"\n  else\n    echo \"$exit_code\"\n  fi\n}\n\n# Get script execution time\nfunction get_script_execution_time() {\n  local script=$1\n  local time=$(yq e \".scripts.$script.execution_time\" \"$CONFIG_FILE\")\n  \n  if [[ \"$time\" == \"null\" ]]; then\n    echo \"-\"\n  else\n    echo \"$time\"\n  fi\n}\n\n# Get script stdout\nfunction get_script_stdout() {\n  local script=$1\n  local stdout=$(yq e \".scripts.$script.stdout\" \"$CONFIG_FILE\")\n  \n  if [[ \"$stdout\" == \"null\" ]]; then\n    echo \"\"\n  else\n    echo \"$stdout\"\n  fi\n}\n\n# Get script stderr\nfunction get_script_stderr() {\n  local script=$1\n  local stderr=$(yq e \".scripts.$script.stderr\" \"$CONFIG_FILE\")\n  \n  if [[ \"$stderr\" == \"null\" ]]; then\n    echo \"\"\n  else\n    echo \"$stderr\"\n  fi\n}\n```\n\n5. Update the script execution function in `src/lib/daemon.sh` to store additional execution details:\n```bash\n# After script execution, add:\nyq e -i \".scripts.$script.last_run = $(date +%s)\" \"$CONFIG_FILE\"\nyq e -i \".scripts.$script.last_status = \\\"$status\\\"\" \"$CONFIG_FILE\"\nyq e -i \".scripts.$script.exit_code = $exit_code\" \"$CONFIG_FILE\"\nyq e -i \".scripts.$script.execution_time = $execution_time\" \"$CONFIG_FILE\"\nyq e -i \".scripts.$script.stdout = \\\"$(escape_yaml \"$stdout\")\\\"\" \"$CONFIG_FILE\"\nyq e -i \".scripts.$script.stderr = \\\"$(escape_yaml \"$stderr\")\\\"\" \"$CONFIG_FILE\"\n\n# Add escape_yaml function\nfunction escape_yaml() {\n  local text=$1\n  echo \"$text\" | sed 's/\\\\/\\\\\\\\/g' | sed 's/\"/\\\\\"/g' | sed 's/\\n/\\\\n/g' | sed 's/\\t/\\\\t/g'\n}\n```\n\n6. Update the documentation to include the new status command options:\n```\nstatus [options]\n  Display the current status of all configured scripts\n\n  Options:\n    --verbose         Show detailed output including stdout/stderr\n    --failed-only     Show only failed scripts\n    --json            Output in JSON format\n```",
            "testStrategy": "1. Test basic status command functionality:\n   - Verify it shows daemon status (running/stopped)\n   - Verify it lists all configured scripts with their status\n   - Check that the formatting is consistent and readable\n\n2. Test JSON output format:\n   - Run `bamon status --json` and verify valid JSON is produced\n   - Validate JSON structure contains all required fields\n   - Verify special characters in script output are properly escaped\n   - Parse the JSON with a tool like jq to confirm it's well-formed\n\n3. Test filtering options:\n   - Configure multiple scripts with different statuses\n   - Run `bamon status --failed-only` and verify only failed scripts are shown\n   - Combine with verbose flag to show detailed output for failed scripts\n   - Combine with JSON flag to get filtered results in JSON format\n\n4. Test execution history storage:\n   - Run multiple scripts and check that history.json is created\n   - Verify the file contains entries for each script execution\n   - Check that timestamps, exit codes, and output are correctly stored\n   - Modify the retention period and verify old entries are pruned\n\n5. Test configuration options:\n   - Change history file location in config and verify it works\n   - Set different retention periods and verify cleanup works correctly\n   - Test with very large history files to ensure performance\n\n6. Test edge cases:\n   - Test with scripts that produce large stdout/stderr output\n   - Test with scripts that include special characters and multi-line output\n   - Test with no scripts configured\n   - Test when history file is corrupted or has invalid JSON\n\n7. Test integration with other commands:\n   - Run scripts with the now command and verify status is updated\n   - Stop and start daemon and verify status command works correctly\n   - Add and remove scripts and check status command reflects changes\n\n8. Performance testing:\n   - Test with a large number of scripts (50+)\n   - Measure response time for both text and JSON output formats\n   - Verify history storage doesn't significantly impact performance"
          }
        ]
      },
      {
        "id": 16,
        "title": "Create Comprehensive README.md Documentation",
        "description": "Create a comprehensive README.md file for the BAMON bash daemon monitor project that includes all necessary documentation for users to understand, install, and use the tool effectively.",
        "details": "1. Create a well-structured README.md with the following sections:\n\n```markdown\n# BAMON - Bash Daemon Monitor\n\n## Overview\n- Brief introduction to BAMON and its purpose\n- Key features and capabilities\n- Project architecture diagram\n\n## Installation\n- System requirements\n- Step-by-step installation instructions using the install.sh script\n- Manual installation instructions\n- Configuration of systemd service\n- Verification steps to confirm successful installation\n\n## Configuration\n- Configuration file structure and location\n- Available configuration options with examples\n- Environment variables\n- Default values and customization options\n\n## Usage\n- Basic command syntax\n- Command reference with examples for each:\n  - Adding scripts to monitor\n  - Removing scripts\n  - Listing monitored scripts\n  - Starting/stopping/restarting the daemon\n  - Checking status\n  - Viewing logs\n- Example workflows for common use cases\n\n## Script Management\n- Script definition format\n- Execution intervals and scheduling\n- Environment and context for script execution\n- Sandboxing and security considerations\n\n## Troubleshooting\n- Common issues and solutions\n- Debugging techniques\n- Log file locations and interpretation\n- Known limitations\n\n## API Reference\n- Complete CLI command reference\n- Arguments and options for each command\n- Return values and exit codes\n- Examples of each command with expected output\n\n## Contributing\n- Guidelines for contributing to the project\n- Development setup\n- Testing procedures\n\n## License\n- License information\n```\n\n2. Include detailed code examples for each command:\n```bash\n# Adding a new script to monitor\nbamon add check_disk --command=\"df -h / | awk 'NR==2 {print \\$5}'\" --interval=300 --description=\"Check disk usage every 5 minutes\"\n\n# Removing a script\nbamon remove check_disk\n\n# Starting the daemon\nbamon start --daemon\n\n# Checking status\nbamon status\n```\n\n3. Create a troubleshooting section with common issues:\n```markdown\n## Troubleshooting\n\n### Daemon fails to start\n- Check if another instance is already running: `bamon status`\n- Verify permissions on configuration directory: `ls -la ~/.config/bamon/`\n- Check logs for specific errors: `cat /var/log/bamon.log`\n\n### Scripts not executing\n- Verify script is enabled: `bamon list`\n- Check script syntax: `bash -n your_script.sh`\n- Review execution logs: `bamon logs --script=script_name`\n```\n\n4. Include a complete API reference table:\n```markdown\n| Command | Description | Options | Example |\n|---------|-------------|---------|---------|\n| add | Add a new script to monitor | --command, --interval, --description, --disabled | `bamon add check_disk --command=\"df -h /\" --interval=300` |\n| remove | Remove a script from monitoring | --force | `bamon remove check_disk --force` |\n| list | List all monitored scripts | --format, --filter | `bamon list --format=json` |\n| start | Start the daemon | --daemon, --config | `bamon start --daemon` |\n| stop | Stop the daemon | --force | `bamon stop` |\n| restart | Restart the daemon | --force | `bamon restart` |\n| status | Check daemon status | --format | `bamon status` |\n| logs | View daemon logs | --follow, --lines, --script | `bamon logs --follow --lines=50` |\n```\n\n5. Create an installation verification section:\n```markdown\n### Verifying Installation\n\nAfter installation, verify BAMON is working correctly:\n\n1. Check the service status:\n   ```\n   systemctl status bamon\n   ```\n\n2. Verify the configuration file exists:\n   ```\n   cat /etc/bamon/config.yaml\n   ```\n\n3. Test adding a simple script:\n   ```\n   bamon add test_script --command=\"echo 'Hello, BAMON!'\" --interval=60\n   ```\n\n4. Check if the script appears in the list:\n   ```\n   bamon list\n   ```\n\n5. View logs to confirm execution:\n   ```\n   bamon logs --script=test_script\n   ```\n```\n\n6. Ensure the README includes information about security considerations:\n```markdown\n## Security Considerations\n\n- BAMON executes scripts in a sandboxed environment with resource limitations\n- Scripts run with the permissions of the user who started the daemon\n- Sensitive information should not be included directly in script commands\n- Use environment variables or secure credential storage for sensitive data\n- Consider running BAMON with a dedicated user with minimal permissions\n```",
        "testStrategy": "1. Verify README.md content is complete and accurate:\n   - Ensure all sections listed in the implementation details are present\n   - Check that all commands and options are documented correctly\n   - Verify examples match the actual implementation\n\n2. Test README.md formatting:\n   - Validate markdown syntax using a markdown linter\n   - Ensure proper heading hierarchy (h1 > h2 > h3)\n   - Check that code blocks are properly formatted with appropriate language tags\n   - Verify tables are correctly formatted and aligned\n\n3. Validate technical accuracy:\n   - Cross-reference command documentation with actual implementation\n   - Ensure all command options are documented with correct syntax\n   - Verify installation instructions work on a clean system\n   - Test troubleshooting steps to confirm they resolve the issues they claim to address\n\n4. Review for completeness:\n   - Ensure all CLI commands are documented\n   - Verify all configuration options are explained\n   - Check that common error scenarios have troubleshooting guidance\n   - Confirm that security considerations are adequately addressed\n\n5. Usability testing:\n   - Have a team member unfamiliar with the project follow the README instructions\n   - Note any points of confusion or missing information\n   - Verify they can successfully install and use the tool following only the README\n\n6. Accessibility and readability:\n   - Check for clear language and avoid unnecessary jargon\n   - Ensure examples are easy to understand\n   - Verify proper use of formatting to enhance readability\n   - Check that diagrams and visual elements have appropriate text descriptions",
        "status": "pending",
        "dependencies": [
          13,
          18,
          11,
          12,
          4,
          2,
          3,
          6,
          7,
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Create Comprehensive Documentation",
        "description": "Develop comprehensive documentation including README, man pages, and usage examples.",
        "details": "1. Create README.md with installation and usage instructions:\n```markdown\n# Bash Daemon Monitor (bamon)\n\nA configurable bash daemon that monitors and executes bash scripts/code snippets at specified intervals, providing a CLI interface for management.\n\n## Features\n\n- Monitor and execute bash scripts at configurable intervals\n- Simple CLI interface for managing monitored scripts\n- Support for HTTP health checks and any bash commands\n- Configurable execution intervals and concurrent execution limits\n- Detailed status reporting and logging\n\n## Installation\n\n### Quick Install\n\n```bash\ngit clone https://github.com/yourusername/bash-daemon-monitor.git\ncd bash-daemon-monitor\nsudo ./install.sh\n```\n\n### Manual Installation\n\n1. Install dependencies:\n   - bash (4.0 or later)\n   - curl (for HTTP health checks)\n   - standard Unix tools\n\n2. Clone the repository:\n   ```bash\n   git clone https://github.com/yourusername/bash-daemon-monitor.git\n   cd bash-daemon-monitor\n   ```\n\n3. Generate the binary:\n   ```bash\n   bashly generate\n   ```\n\n4. Install manually:\n   ```bash\n   sudo cp ./bamon /usr/local/bin/\n   sudo mkdir -p /etc/bamon\n   sudo cp ./config.yaml.example /etc/bamon/config.yaml\n   ```\n\n## Usage\n\n### Basic Commands\n\n- **Start the daemon:**\n  ```bash\n  bamon start --daemon\n  ```\n\n- **Check status:**\n  ```bash\n  bamon status\n  ```\n\n- **Add a script to monitor:**\n  ```bash\n  bamon add \"disk_check\" --command \"df -h / | awk 'NR==2 {print $5}' | sed 's/%//' | awk '{if($1>80) exit 1; else exit 0}'\" --interval 300 --description \"Check if disk usage is under 80%\"\n  ```\n\n- **Run all scripts now:**\n  ```bash\n  bamon now\n  ```\n\n- **Stop the daemon:**\n  ```bash\n  bamon stop\n  ```\n\n### Configuration\n\nThe default configuration file is located at `/etc/bamon/config.yaml`. You can specify a custom configuration file with the `--config` option.\n\nExample configuration:\n\n```yaml\ndaemon:\n  default_interval: 60\n  log_file: \"/var/log/bamon/bamon.log\"\n  pid_file: \"/var/run/bamon.pid\"\n  max_concurrent: 10\n\nscripts:\n  - name: \"google_health_check\"\n    command: \"curl -s -o /dev/null -w '%{http_code}' https://google.com; [ \"$code\" -eq 200 ] || { echo \"$code\"; exit 1; }\"\n    interval: 30\n    enabled: true\n    description: \"Check if Google is accessible\"\n  \n  - name: \"disk_space_check\"\n    command: \"df -h / | awk 'NR==2 {print $5}' | sed 's/%//' | awk '{if($1>80) exit 1; else exit 0}'\"\n    interval: 300\n    enabled: true\n    description: \"Check if disk usage is under 80%\"\n```\n\n## Examples\n\n### HTTP Health Check\n\n```bash\nbamon add \"website_check\" --command \"curl -s -o /dev/null -w '%{http_code}' https://example.com; [ $? -eq 0 ] || exit 1\" --interval 60 --description \"Check if example.com is accessible\"\n```\n\n### System Resource Check\n\n```bash\nbamon add \"memory_check\" --command \"free -m | awk '/^Mem:/ {print $3/$2 * 100.0}' | awk '{if($1>90) exit 1; else exit 0}'\" --interval 300 --description \"Check if memory usage is under 90%\"\n```\n\n### Process Check\n\n```bash\nbamon add \"nginx_check\" --command \"pgrep nginx > /dev/null || exit 1\" --interval 60 --description \"Check if Nginx is running\"\n```\n\n## License\n\nMIT\n```\n\n2. Create man page in `docs/bamon.1.md`:\n```markdown\n% BAMON(1) Bash Daemon Monitor 0.1.0\n% Your Name\n% November 2023\n\n# NAME\n\nbamon - Bash Daemon Monitor\n\n# SYNOPSIS\n\n**bamon** *command* [options]\n\n# DESCRIPTION\n\nBash Daemon Monitor (bamon) is a tool for monitoring and executing bash scripts at specified intervals. It provides a simple CLI interface for managing monitored scripts.\n\n# COMMANDS\n\n**status** [options]\n: Display current status of all configured scripts\n\n**add** *name* [options]\n: Add a new script to monitor\n\n**remove** *name* [options]\n: Remove a script from monitoring\n\n**now** [options]\n: Execute all enabled scripts immediately\n\n**start** [options]\n: Start the daemon process\n\n**stop** [options]\n: Stop the daemon process\n\n**restart** [options]\n: Restart the daemon process\n\n**list** [options]\n: List all configured scripts\n\n# OPTIONS\n\n## Global Options\n\n**--help**\n: Show help message\n\n**--version**\n: Show version information\n\n## Status Command Options\n\n**--verbose**, **-v**\n: Show detailed information including full output\n\n**--failed-only**, **-f**\n: Show only failed scripts\n\n## Add Command Options\n\n**--command**, **-c** *command*\n: Bash command/code to execute\n\n**--interval**, **-i** *seconds*\n: Execution interval in seconds (default: 60)\n\n**--description**, **-d** *text*\n: Description of what the script does\n\n**--enabled**\n: Set script as enabled (default)\n\n**--disabled**\n: Set script as disabled\n\n## Remove Command Options\n\n**--force**, **-f**\n: Remove without confirmation\n\n## Now Command Options\n\n**--name**, **-n** *script_name*\n: Execute only specific script by name\n\n**--async**, **-a**\n: Execute scripts asynchronously (default: sequential)\n\n## Start Command Options\n\n**--daemon**, **-d**\n: Run in background (daemon mode)\n\n**--config**, **-c** *file*\n: Specify custom config file path\n\n## Stop Command Options\n\n**--force**, **-f**\n: Force kill the daemon\n\n## List Command Options\n\n**--enabled-only**, **-e**\n: Show only enabled scripts\n\n**--disabled-only**, **-d**\n: Show only disabled scripts\n\n# FILES\n\n**/etc/bamon/config.yaml**\n: Default configuration file\n\n**/var/log/bamon/bamon.log**\n: Default log file\n\n**/var/run/bamon.pid**\n: Default PID file\n\n# EXAMPLES\n\nStart the daemon in background:\n\n    bamon start --daemon\n\nAdd a script to monitor disk space:\n\n    bamon add disk_check --command \"df -h / | awk 'NR==2 {print $5}' | sed 's/%//' | awk '{if($1>80) exit 1; else exit 0}'\" --interval 300 --description \"Check if disk usage is under 80%\"\n\nCheck status of all scripts:\n\n    bamon status\n\nExecute all scripts immediately:\n\n    bamon now\n\n# SEE ALSO\n\n**bash**(1), **curl**(1)\n```\n\n3. Create usage examples in `docs/examples.md`\n4. Add inline documentation in all source files\n5. Create a FAQ document addressing common questions\n6. Add troubleshooting guide for common issues",
        "testStrategy": "1. Verify README contains all required information for installation and usage\n2. Test man page generation and formatting\n3. Verify examples work as documented\n4. Test inline documentation is accessible through --help commands\n5. Verify FAQ addresses common questions and issues\n6. Test troubleshooting guide with simulated issues",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement execution history storage and retrieval",
        "description": "Enhance the configuration system to store and retrieve execution history data for status reporting",
        "details": "Update the configuration system to properly store and retrieve execution history data including last run time, status, duration, and error messages. Ensure the status check command can access this data efficiently without triggering new executions. Handle cases where execution data is incomplete or missing.",
        "status": "pending",
        "dependencies": [
          "15.1",
          "15.3",
          15
        ],
        "priority": "high"
      }
    ],
    "metadata": {
      "created": "2025-09-12T23:10:00.761Z",
      "updated": "2025-09-13T17:30:53.220Z",
      "description": "Tasks for master context"
    }
  }
}