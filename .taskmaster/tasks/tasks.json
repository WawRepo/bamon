{
  "master": {
    "tasks": [
      {
        "id": 25,
        "title": "Setup Project Structure and Configuration Management",
        "description": "Create the initial project structure and implement configuration management using YAML for the Bash Daemon Monitor.",
        "details": "1. Create the directory structure as specified in the PRD:\n   ```\n   bamon/\n   ‚îú‚îÄ‚îÄ bamon                    # Main executable (generated by bashly)\n   ‚îú‚îÄ‚îÄ bashly.yml              # Bashly configuration\n   ‚îú‚îÄ‚îÄ src/\n   ‚îÇ   ‚îú‚îÄ‚îÄ lib/\n   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.sh       # Configuration management\n   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ execution.sh    # Script execution and daemon loop\n   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logging.sh      # Logging functions\n   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sandbox.sh      # Script sandboxing\n   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ performance.sh  # Performance optimization\n   ‚îÇ   ‚îî‚îÄ‚îÄ *_command.sh        # CLI command implementations\n   ‚îú‚îÄ‚îÄ config.yaml             # Daemon configuration\n   ‚îî‚îÄ‚îÄ install.sh              # Installation script\n   ```\n2. Set up the Bashly configuration file (bashly.yml) with command structure:\n   - Define all commands: status, add, remove, list, now, start, stop, restart, performance, config\n   - Include subcommands for config: edit, show, validate\n   - Define command options and arguments\n3. Implement the config.sh library for YAML configuration management:\n   - Use 'yq' (version 4.x+) for YAML parsing\n   - Implement functions to read, validate, and write configuration\n   - Create default configuration if none exists\n   - Support environment variable overrides\n4. Create the default config.yaml template with all required sections:\n   - daemon section with default_interval, log_file, pid_file, etc.\n   - sandbox section with timeout, max_cpu_time, etc.\n   - performance section with monitoring settings\n   - scripts section with sample monitoring scripts\n5. Implement configuration validation to ensure all required fields exist\n6. Create helper functions for accessing configuration values throughout the application",
        "testStrategy": "1. Verify the project structure is created correctly\n2. Test configuration loading with valid and invalid YAML files\n3. Verify default configuration is created when none exists\n4. Test configuration validation with missing required fields\n5. Verify environment variable overrides work correctly\n6. Test reading and writing configuration values\n7. Verify the Bashly configuration generates the expected CLI structure\n8. Test the config command and its subcommands",
        "priority": "high",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Implement Logging System and Daemon Process Management",
        "description": "Create the logging system with configurable levels and implement daemon process management functionality.",
        "details": "1. Implement the logging.sh library with the following features:\n   - Support for configurable log levels (DEBUG, INFO, WARN, ERROR)\n   - Log rotation functionality to prevent disk space issues\n   - Functions for logging to both console and file\n   - Timestamp and log level prefixing\n   - Support for redirecting both stdout and stderr to log file in daemon mode\n2. Implement daemon process management:\n   - Create functions to start the daemon in background mode\n   - Implement PID file management for tracking the daemon process\n   - Create stop functionality to terminate the daemon gracefully\n   - Implement restart functionality\n   - Add signal handling for graceful shutdown (SIGTERM, SIGINT)\n3. Set up log file location at ~/.config/bamon/daemon.log (configurable)\n4. Implement foreground mode (without --daemon flag) that outputs to terminal\n5. Create functions to check daemon status (running/stopped)\n6. Implement proper error handling for daemon management operations\n7. Use 'nohup' and output redirection (2>&1) for background operation\n8. Add log rotation based on file size or time interval\n9. Implement log level filtering based on configuration",
        "testStrategy": "1. Test logging at different log levels\n2. Verify log rotation works when log file reaches size limit\n3. Test daemon start in both foreground and background modes\n4. Verify PID file is created and managed correctly\n5. Test daemon stop and verify process is terminated\n6. Test restart functionality\n7. Verify signal handling for graceful shutdown\n8. Test log output redirection in daemon mode\n9. Verify error handling for various failure scenarios\n10. Test log level filtering based on configuration",
        "priority": "high",
        "dependencies": [
          25
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Script Execution and Sandboxing",
        "description": "Create the core script execution engine with sandboxing and resource limits for running monitoring scripts safely.",
        "details": "1. Implement the execution.sh library for script execution:\n   - Create functions to execute bash commands and scripts\n   - Implement interval-based execution scheduling\n   - Add support for different script types (commands, HTTP checks, scripts)\n   - Capture both stdout and stderr from script execution\n   - Track execution time, exit codes, and resource usage\n2. Implement the sandbox.sh library for script isolation:\n   - Use 'timeout' command (from GNU coreutils) for execution time limits\n   - Implement resource limits using ulimit for CPU, memory, and file size\n   - Create temporary directories for script execution\n   - Implement cleanup of temporary resources after execution\n   - Add error detection for various failure types (timeout, memory, permissions)\n3. Create the main daemon loop for continuous monitoring:\n   - Schedule script execution based on configured intervals\n   - Implement non-blocking execution to allow concurrent scripts\n   - Track next execution time for each script\n   - Handle script failures gracefully\n4. Implement execution history storage:\n   - Store execution results in JSON format\n   - Include success/failure status, exit codes, output, timestamps\n   - Implement history retention policy based on configuration\n   - Store history at ~/.config/bamon/execution_history.json (configurable)\n5. Add support for manual execution via 'now' command\n6. Implement concurrent execution management with configurable limits",
        "testStrategy": "1. Test script execution with various script types\n2. Verify resource limits are enforced correctly\n3. Test timeout functionality with long-running scripts\n4. Verify stdout and stderr are captured correctly\n5. Test execution history storage and retrieval\n6. Verify interval-based scheduling works correctly\n7. Test concurrent execution with multiple scripts\n8. Verify cleanup of temporary resources\n9. Test manual execution via 'now' command\n10. Verify error handling for various script failure scenarios\n11. Test history retention policy",
        "priority": "high",
        "dependencies": [
          25,
          26
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement Script Management Commands",
        "description": "Create the CLI commands for managing monitoring scripts, including add, remove, list, and status functionality.",
        "details": "1. Implement the add_command.sh for adding new scripts:\n   - Accept script name, command, and interval parameters\n   - Validate input parameters\n   - Add new script to configuration file\n   - Support for enabling/disabling scripts\n   - Handle duplicate script names\n2. Implement the remove_command.sh for removing scripts:\n   - Accept script name parameter\n   - Remove script from configuration\n   - Handle non-existent script names\n3. Implement the list_command.sh for listing scripts:\n   - Display all configured scripts with details\n   - Show enabled/disabled status\n   - Include interval and command information\n   - Support for filtering and sorting options\n4. Implement the now_command.sh for immediate execution:\n   - Execute all scripts immediately\n   - Show execution results\n   - Support for executing specific scripts\n5. Create helper functions for script management operations\n6. Implement validation for script commands and intervals\n7. Add support for script enabling/disabling\n8. Implement proper error handling and user feedback",
        "testStrategy": "1. Test adding scripts with various parameters\n2. Verify duplicate script names are handled correctly\n3. Test removing scripts and verify they're removed from configuration\n4. Verify list command shows all configured scripts\n5. Test immediate execution with 'now' command\n6. Verify validation works for script commands and intervals\n7. Test enabling and disabling scripts\n8. Verify error handling for various failure scenarios\n9. Test with invalid inputs and verify appropriate error messages",
        "priority": "medium",
        "dependencies": [
          25,
          26,
          27
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implement Status Command with Enhanced Output",
        "description": "Create the status command with comprehensive reporting, including context-aware output display and JSON format support.",
        "details": "1. Implement the status_command.sh with the following features:\n   - Display current status of all monitored scripts\n   - Show success/failure status with clear indicators\n   - Include exit codes, output, execution duration, and timestamps\n   - Support for JSON output format with --json flag\n   - Implement filtering with --failed-only flag\n   - Support for sorting by status, execution time, or script name\n2. Implement context-aware output display:\n   - Show stdout for successful executions\n   - Show intelligent error messages for failures based on error type\n   - Handle timeout, memory, permission, file, and network errors\n   - Implement proper truncation for table view (30 characters)\n   - Show truncation message \"(truncated - use --json)\" for long output\n   - Handle multiline output appropriately\n3. Implement JSON output format:\n   - Include complete execution details without truncation\n   - Proper JSON formatting for multiline output (as array)\n   - Include all metadata (timestamps, duration, exit codes)\n   - No base64 encoding, use proper JSON escaping\n4. Create tabular output format:\n   - Define columns: NAME | STATUS | EXIT CODE | OUTPUT | DURATION | TIME SINCE | NEXT EXECUTION\n   - Implement consistent column widths and alignment\n   - Handle long values with truncation\n   - Use color coding for status (if supported)\n5. Implement intelligent error message generation based on exit codes and output patterns",
        "testStrategy": "1. Test status command with various script states\n2. Verify JSON output format contains complete data\n3. Test output truncation in table view\n4. Verify filtering with --failed-only flag\n5. Test sorting options\n6. Verify intelligent error messages for different failure types\n7. Test with multiline output and verify proper handling\n8. Verify column alignment and truncation in table view\n9. Test with various output lengths and verify consistent truncation\n10. Verify color coding works in supported terminals",
        "priority": "high",
        "dependencies": [
          25,
          26,
          27,
          28
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement Performance Optimization and Monitoring",
        "description": "Create the performance monitoring and optimization system to manage system load and resource usage.",
        "details": "1. Implement the performance.sh library with the following features:\n   - System load monitoring using /proc/loadavg or uptime command\n   - CPU, memory, and disk usage tracking\n   - Adaptive scheduling based on system performance\n   - Resource usage tracking per script\n2. Implement the performance_command.sh:\n   - Display system performance metrics\n   - Show optimization status and settings\n   - Include script-specific performance data\n   - Support for enabling/disabling performance optimization\n3. Create concurrent execution management:\n   - Limit number of simultaneously running scripts\n   - Implement queue for scripts when system is at capacity\n   - Add priority scheduling for high-priority scripts\n4. Implement adaptive scheduling:\n   - Adjust execution intervals based on system load\n   - Skip executions during high load periods\n   - Resume normal scheduling when load decreases\n5. Add performance metrics collection:\n   - Track execution times for each script\n   - Monitor success/failure rates\n   - Track resource usage (CPU, memory, time)\n   - Calculate averages and trends\n6. Implement configuration options for performance settings:\n   - load_threshold for determining high load\n   - max_concurrent for limiting simultaneous executions\n   - optimize_scheduling for enabling/disabling optimization",
        "testStrategy": "1. Test system load monitoring under various conditions\n2. Verify concurrent execution limits are enforced\n3. Test adaptive scheduling during high load\n4. Verify performance metrics collection\n5. Test performance command output\n6. Verify queue management for scripts\n7. Test priority scheduling for high-priority scripts\n8. Verify configuration options affect behavior correctly\n9. Test with various system load scenarios\n10. Verify resource usage tracking per script",
        "priority": "medium",
        "dependencies": [
          25,
          26,
          27
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Create Installation Script and Documentation",
        "description": "Develop the installation script for different environments and create comprehensive documentation for the project.",
        "details": "1. Implement the install.sh script with the following features:\n   - Support for user installation (default to ~/.local/bin/)\n   - Support for system installation (with --system flag)\n   - Support for custom installation path (with --prefix flag)\n   - Dependency checking and installation\n   - Configuration directory setup\n   - Sample script installation\n   - PATH setup assistance\n2. Create comprehensive documentation:\n   - README.md with project overview, installation, and usage\n   - Command reference with examples for all commands\n   - Configuration guide with YAML examples\n   - Sample script documentation\n   - Troubleshooting guide\n   - Development setup instructions\n3. Implement platform-specific installation support:\n   - macOS with Homebrew dependencies\n   - Linux with package manager dependencies\n   - WSL2 support\n4. Create man pages for all commands:\n   - Main man page (bamon.1)\n   - Command-specific man pages (bamon-status.1, etc.)\n5. Add installation validation and rollback:\n   - Verify installation was successful\n   - Provide rollback in case of failure\n   - Check for required dependencies\n6. Implement uninstall functionality\n7. Create sample scripts for common monitoring tasks",
        "testStrategy": "1. Test installation on different platforms (macOS, Linux, WSL2)\n2. Verify dependency checking works correctly\n3. Test user, system, and custom installation paths\n4. Verify configuration directory is created correctly\n5. Test PATH setup assistance\n6. Verify sample scripts are installed\n7. Test uninstall functionality\n8. Verify documentation accuracy and completeness\n9. Test installation validation and rollback\n10. Verify man pages are installed correctly",
        "priority": "medium",
        "dependencies": [
          25,
          26,
          27,
          28,
          29,
          30
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement CI/CD and Release Automation",
        "description": "Set up GitHub workflows for continuous integration, testing, and automated release management.",
        "details": "1. Create GitHub workflow files:\n   - ci.yml for continuous integration\n   - release.yml for release automation\n2. Implement CI workflow with the following features:\n   - Trigger on commits to main branch\n   - Run tests in Ubuntu container environment\n   - Install dependencies (bash, curl, yq, coreutils)\n   - Execute test suite\n   - Report status to GitHub PR/commit\n3. Implement release workflow:\n   - Manual trigger (workflow_dispatch)\n   - Version detection and bumping\n   - Update version in bashly.yml\n   - Regenerate binary with bashly\n   - Create git tag with new version\n   - Package release assets\n   - Create GitHub release with assets and notes\n4. Implement version management:\n   - Use semantic versioning (MAJOR.MINOR.PATCH)\n   - Automated patch bumping\n   - Git tag format with 'v' prefix (e.g., v0.1.0)\n5. Set up release asset packaging:\n   - Include bamon binary\n   - Include install.sh script\n   - Include documentation and samples\n   - Include tests\n6. Create test environment in Ubuntu container:\n   - Fresh Ubuntu container (latest LTS)\n   - Install dependencies\n   - Run installation script\n   - Execute test suite\n7. Implement BATS (Bash Automated Testing System) tests:\n   - Command functionality tests\n   - Daemon execution tests\n   - Configuration management tests\n   - Performance monitoring tests\n   - Installation tests",
        "testStrategy": "1. Verify CI workflow runs on commits to main branch\n2. Test release workflow with manual trigger\n3. Verify version bumping works correctly\n4. Test binary regeneration with bashly\n5. Verify git tag creation\n6. Test release asset packaging\n7. Verify GitHub release creation\n8. Test in Ubuntu container environment\n9. Verify BATS tests run correctly\n10. Test installation from release assets",
        "priority": "medium",
        "dependencies": [
          25,
          26,
          27,
          28,
          29,
          30,
          31
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Create GitHub Workflows for CI/CD and Release Automation",
        "description": "Implement GitHub Actions workflows for continuous integration testing and automated release management, including version control and asset packaging.",
        "status": "done",
        "dependencies": [
          25,
          31
        ],
        "priority": "high",
        "details": "1. Create the GitHub workflow directory structure:\n   ```\n   .github/\n   ‚îî‚îÄ‚îÄ workflows/\n       ‚îú‚îÄ‚îÄ ci.yml\n       ‚îî‚îÄ‚îÄ release.yml\n   ```\n\n2. Implement the CI workflow (ci.yml) with the following features:\n   - Configure workflow to trigger on push to main branch and pull requests\n   - Set up Ubuntu latest runner environment\n   - Install required dependencies (bash, curl, yq, jq, coreutils, bats, docker)\n   - Check out repository with fetch-depth: 0 for complete history\n   - Binary generation using bashly\n   - Run container-based tests using Docker\n   - Execute the test suite with proper error reporting (BATS tests + container tests)\n   - Installation script validation\n   - CLI command testing\n   - Cache dependencies to speed up workflow runs\n   - Add status badges to README.md\n\n3. Implement the release workflow (release.yml) with the following features:\n   - Configure manual trigger using workflow_dispatch\n   - Add inputs for version bump type (patch/minor/major)\n   - Add dry run capability for testing\n   - Set up Ubuntu latest runner environment\n   - Install required dependencies (bash, curl, yq, jq, coreutils, bashly)\n   - Check out repository with fetch-depth: 0 for complete history\n   - Implement version detection logic:\n     - Fetch all git tags\n     - Extract highest semantic version tag using `git describe --tags --abbrev=0`\n     - Increment version according to semver rules (patch by default)\n   - Update version in bashly.yml configuration\n   - Regenerate binary using bashly generate\n   - Create git tag with new version\n   - Package release assets:\n     - bamon binary\n     - install.sh script\n     - docs/ directory\n     - samples/ directory\n     - tests/ directory\n   - Create GitHub release with all assets\n   - Push changes back to repository\n\n4. Add GitHub token permissions configuration:\n   - contents: write (for creating releases and tags)\n   - packages: read (for dependency access)\n   - actions: read (for workflow runs)\n\n5. Implement error handling and notifications:\n   - Add failure notifications via GitHub notifications\n   - Implement detailed error reporting in workflow logs\n   - Add retry logic for network-dependent steps\n\n6. Document workflows in README.md:\n   - Add section explaining CI/CD process\n   - Include instructions for manual release triggering\n   - Document version bumping process",
        "testStrategy": "1. Test CI workflow functionality:\n   - Make a test commit to main branch and verify workflow triggers automatically\n   - Create a pull request and confirm tests run on PR\n   - Intentionally break a test and verify the workflow fails appropriately\n   - Check that status badges update correctly\n   - Verify binary generation works correctly\n   - Test installation script validation\n   - Confirm CLI command testing works as expected\n\n2. Test release workflow functionality:\n   - Manually trigger the release workflow with patch version bump\n   - Test the dry run capability to verify workflow without creating actual releases\n   - Verify version detection correctly identifies the highest existing tag\n   - Confirm version in bashly.yml is updated correctly\n   - Validate that binary is regenerated with updated version\n   - Check that git tag is created with correct version format (v1.2.3)\n   - Verify all required assets are included in the GitHub release\n   - Test downloading assets from the release and verify integrity\n\n3. Test error handling:\n   - Simulate network failure during dependency installation\n   - Verify retry logic works as expected\n   - Test with invalid version format and verify appropriate error message\n\n4. Test permissions and security:\n   - Verify workflow runs with minimal required permissions\n   - Confirm secure handling of GitHub token\n   - Test that workflow cannot be triggered by unauthorized users\n\n5. Test in different environments:\n   - Verify release assets work on Ubuntu, macOS, and WSL2\n   - Test installation script from release assets\n   - Validate documentation accuracy for release process",
        "subtasks": [
          {
            "id": 1,
            "title": "Create GitHub workflows directory structure",
            "description": "Set up the .github/workflows/ directory structure for CI and release workflows",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement CI workflow (ci.yml)",
            "description": "Create the continuous integration workflow with automatic triggers, dependency installation, test execution, and error handling",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Release workflow (release.yml)",
            "description": "Create the release automation workflow with version bumping, asset packaging, and GitHub release creation",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Test workflows in GitHub Actions",
            "description": "Verify both CI and release workflows function correctly in the GitHub Actions environment",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Verify version bumping logic",
            "description": "Test the semantic versioning bump logic for patch, minor, and major versions",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Test release asset creation and upload",
            "description": "Verify all release assets are correctly packaged and uploaded to GitHub releases",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Update README.md with CI/CD documentation",
            "description": "Add documentation about the CI/CD process, release automation, and installation instructions using the latest release",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 34,
        "title": "Implement Install Script Configuration Preservation",
        "description": "Enhance the install.sh script to detect and preserve existing BAMON configurations, preventing accidental overrides while still updating the binary.",
        "details": "1. Modify the install.sh script to include configuration preservation logic:\n   - Add a check for the existence of ~/.config/bamon/config.yaml before attempting to create or modify configuration\n   - Implement conditional logic to skip configuration setup when an existing config is detected\n   - Add code to skip sample script installation when preserving existing configuration\n   - Ensure the binary is still updated regardless of configuration status\n   - Display clear, user-friendly messages about configuration preservation\n\n2. Implementation approach:\n```bash\n# Check for existing configuration\nif [ -f \"${CONFIG_DIR}/config.yaml\" ]; then\n    echo \"‚ÑπÔ∏è Existing BAMON configuration detected at ${CONFIG_DIR}/config.yaml\"\n    echo \"‚ÑπÔ∏è Preserving your current configuration and scripts\"\n    PRESERVE_CONFIG=true\nelse\n    PRESERVE_CONFIG=false\nfi\n\n# Update binary regardless of configuration status\necho \"üì¶ Installing BAMON binary to ${INSTALL_PATH}...\"\ncp ./bamon \"${INSTALL_PATH}/bamon\"\nchmod +x \"${INSTALL_PATH}/bamon\"\n\n# Only setup configuration if not preserving\nif [ \"$PRESERVE_CONFIG\" = false ]; then\n    echo \"üîß Setting up configuration directory at ${CONFIG_DIR}...\"\n    mkdir -p \"${CONFIG_DIR}\"\n    # Configuration setup code here...\n    \n    echo \"üìù Installing sample scripts...\"\n    # Sample script installation code here...\nelse\n    echo \"üîí Skipping configuration setup to preserve existing settings\"\n    echo \"‚úÖ BAMON binary has been updated successfully\"\nfi\n```\n\n3. Ensure proper error handling:\n   - Add appropriate error messages if binary update fails\n   - Implement verbose logging with the --verbose flag to help troubleshoot installation issues\n   - Add a --force flag option to override existing configuration if explicitly requested\n\n4. Update help text and usage information to reflect the new behavior:\n```bash\necho \"Usage: ./install.sh [OPTIONS]\"\necho \"Options:\"\necho \"  --prefix PATH    Install to custom location (default: ~/.local/bin)\"\necho \"  --system         Install system-wide (requires sudo)\"\necho \"  --force          Override existing configuration (use with caution)\"\necho \"  --verbose        Show detailed installation information\"\necho \"  --help           Show this help message\"\n```",
        "testStrategy": "1. Test installation with no existing configuration:\n   - Remove any existing ~/.config/bamon directory\n   - Run the install script\n   - Verify that both the binary and configuration are installed correctly\n   - Check that sample scripts are installed\n\n2. Test installation with existing configuration:\n   - Create a test configuration at ~/.config/bamon/config.yaml with known content\n   - Run the install script\n   - Verify that the binary is updated\n   - Confirm the existing configuration file is unchanged\n   - Verify that no sample scripts were added or modified\n   - Check that appropriate messages about configuration preservation are displayed\n\n3. Test with --force flag:\n   - Create a test configuration\n   - Run install script with --force flag\n   - Verify that both binary and configuration are updated, overriding existing files\n   - Confirm sample scripts are installed\n\n4. Test in different environments:\n   - Test on Ubuntu, Debian, and other major Linux distributions\n   - Test on macOS\n   - Test on Windows Subsystem for Linux (WSL)\n\n5. Test with different installation paths:\n   - Test with default user installation\n   - Test with --system flag for system-wide installation\n   - Test with --prefix flag for custom installation location\n\n6. Verify error handling:\n   - Test with read-only configuration directory\n   - Test with insufficient permissions\n   - Verify appropriate error messages are displayed",
        "status": "done",
        "dependencies": [
          31
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Configuration Detection Logic",
            "description": "Add logic to detect existing configuration files and set appropriate flags for preservation",
            "dependencies": [],
            "details": "Create the initial detection mechanism that checks for ~/.config/bamon/config.yaml existence. Implement the PRESERVE_CONFIG flag that will control the installation flow. Add clear user messages that inform about configuration detection and preservation intent.",
            "status": "done",
            "testStrategy": "Test with both existing and non-existing configuration files. Verify the PRESERVE_CONFIG flag is set correctly in both scenarios. Ensure appropriate messages are displayed to the user."
          },
          {
            "id": 2,
            "title": "Implement Binary Update Mechanism",
            "description": "Ensure the BAMON binary is updated regardless of configuration preservation status",
            "dependencies": [
              "34.1"
            ],
            "details": "Modify the install script to always copy and set permissions for the BAMON binary, regardless of whether configuration is being preserved. Add appropriate error handling for binary installation failures. Implement verbose logging for the binary update process when --verbose flag is used.",
            "status": "done",
            "testStrategy": "Test binary installation with both new and existing configurations. Verify binary is properly updated in both scenarios. Test error handling by simulating permission issues or missing files."
          },
          {
            "id": 3,
            "title": "Implement Conditional Configuration Setup",
            "description": "Add conditional logic to skip configuration setup when preserving existing configuration",
            "dependencies": [
              "34.1",
              "34.2"
            ],
            "details": "Modify the configuration setup section to only execute when PRESERVE_CONFIG is false. This includes directory creation, config file copying, and sample script installation. Ensure all configuration-related operations are properly wrapped in the conditional block.",
            "status": "done",
            "testStrategy": "Test installation with and without existing configuration. Verify that configuration files remain untouched when PRESERVE_CONFIG is true. Confirm that new configuration is properly set up when PRESERVE_CONFIG is false."
          },
          {
            "id": 4,
            "title": "Implement Force Override Option",
            "description": "Add a --force flag to allow users to explicitly override existing configuration",
            "dependencies": [
              "34.1",
              "34.3"
            ],
            "details": "Add command-line argument parsing for the --force flag. Modify the configuration detection logic to respect the force flag, overriding the PRESERVE_CONFIG value when --force is specified. Add appropriate warning messages when force override is used.",
            "status": "done",
            "testStrategy": "Test installation with --force flag and existing configuration. Verify that configuration is overwritten despite existing files. Test without --force and confirm preservation behavior is maintained."
          },
          {
            "id": 5,
            "title": "Update Help Text and Documentation",
            "description": "Update the script's help text and usage information to reflect the new behavior",
            "dependencies": [
              "34.1",
              "34.2",
              "34.3",
              "34.4"
            ],
            "details": "Update the help text to include information about configuration preservation behavior. Add documentation for the new --force flag. Ensure all usage examples and option descriptions are accurate. Add a section explaining the configuration preservation feature in the main documentation.",
            "status": "done",
            "testStrategy": "Verify help text is displayed correctly with the --help flag. Ensure all new options are documented. Check that the explanation of configuration preservation is clear and accurate."
          }
        ]
      },
      {
        "id": 35,
        "title": "Implement Comprehensive Documentation System with MkDocs",
        "description": "Create a modern documentation system using MkDocs with Material theme, including a redesigned README, structured documentation pages, command references, and automated GitHub Pages deployment.",
        "status": "done",
        "dependencies": [
          25,
          31,
          33
        ],
        "priority": "high",
        "details": "1. **README.md Redesign**:\n   - Create a concise, Helm-style README (max 100 lines) with clear project title, tagline, brief description, installation instructions, basic usage examples, and links to detailed documentation\n   - Follow modern README best practices with badges, clear formatting, and visual hierarchy\n   - Include BAMON logo from `docs/bamon_logo.png` prominently at the top of README.md\n\n2. **MkDocs Setup and Configuration**:\n   - Install MkDocs and Material theme: `pip install mkdocs mkdocs-material`\n   - Follow the official [MkDocs Getting Started Guide](https://www.mkdocs.org/getting-started/) for setup and best practices\n   - Create initial mkdocs.yml configuration file with:\n     ```yaml\n     site_name: BAMON\n     site_description: Bash Daemon Monitor - A lightweight monitoring solution\n     theme:\n       name: material\n       palette:\n         primary: indigo\n         accent: indigo\n       features:\n         - navigation.tabs\n         - navigation.sections\n         - search.suggest\n         - search.highlight\n       logo: bamon_logo.png\n       favicon: bamon_logo.png\n     markdown_extensions:\n       - admonition\n       - codehilite\n       - pymdownx.superfences\n       - pymdownx.tabbed\n     ```\n   - Configure navigation structure in mkdocs.yml\n   - Implement recommended MkDocs features like navigation, search, and theming\n\n3. **Documentation Structure Implementation**:\n   - Create the following documentation pages in the docs/ directory:\n     - index.md (Home/Overview)\n     - installation.md (Detailed installation guide)\n     - uninstallation.md (Uninstallation instructions)\n     - commands/ (Directory for command reference pages)\n       - index.md (Commands overview)\n       - Individual .md files for each BAMON command\n     - configuration.md (Configuration reference)\n     - examples.md (Examples and use cases)\n     - troubleshooting.md (Troubleshooting guide)\n     - api.md (API reference for developers)\n   - Ensure consistent formatting and style across all pages\n   - Ensure consistent branding with logo across all documentation pages\n\n4. **Command Documentation Development**:\n   - Create a template for command documentation pages with:\n     - Command syntax and description\n     - Options/flags reference table\n     - 3-5 practical examples with expected output\n     - Related commands section\n   - Document each BAMON command using this template\n   - Include command output examples in code blocks\n\n5. **GitHub Pages Integration**:\n   - Create .github/workflows/docs.yml with:\n     ```yaml\n     name: Build and deploy documentation\n     on:\n       push:\n         paths:\n           - 'docs/**'\n           - 'mkdocs.yml'\n     jobs:\n       deploy:\n         runs-on: ubuntu-latest\n         steps:\n           - uses: actions/checkout@v3\n           - uses: actions/setup-python@v4\n             with:\n               python-version: 3.x\n           - run: pip install mkdocs-material\n           - run: mkdocs gh-deploy --force\n     ```\n   - Configure GitHub repository settings for GitHub Pages\n   - Add CNAME file if using custom domain\n\n6. **Content Migration and Quality Control**:\n   - Remove all current .md files from docs/ directory\n   - Extract and consolidate useful content from existing documentation\n   - Implement documentation quality controls:\n     - Test all code examples for accuracy\n     - Add automated link validation using mkdocs-linkcheck\n     - Integrate spell checking with mkdocs-spellcheck\n     - Create documentation review checklist\n\n7. **Local Testing and Preview**:\n   - Test documentation locally with `mkdocs serve`\n   - Verify responsive design on different devices\n   - Check search functionality\n   - Validate all links and examples\n\n8. **Logo Integration**:\n   - Ensure logo file is available at `docs/bamon_logo.png`\n   - Verify logo is properly sized and positioned in README.md\n   - Configure logo in MkDocs site header and as favicon\n   - Test logo display on different screen sizes for responsiveness\n   - Use high-resolution logo for crisp display across all platforms",
        "testStrategy": "1. **README.md Verification**:\n   - Verify README.md is under 100 lines\n   - Confirm it contains all required sections (title, tagline, description, installation, usage, links)\n   - Check that all links in README.md are valid and working\n   - Ensure README renders correctly on GitHub\n   - Verify BAMON logo displays correctly at the top of README.md\n\n2. **MkDocs Setup Testing**:\n   - Run `mkdocs build` and verify it completes without errors\n   - Run `mkdocs serve` and test local preview at http://127.0.0.1:8000/\n   - Test navigation structure and ensure all pages are accessible\n   - Verify search functionality works correctly\n   - Test responsive design by resizing browser window and using mobile device emulation\n   - Verify logo appears correctly in site header and as favicon\n\n3. **Documentation Structure Testing**:\n   - Verify all required pages exist and are properly linked in navigation\n   - Check that navigation hierarchy matches the planned structure\n   - Ensure consistent formatting across all pages\n   - Verify all internal links between documentation pages work correctly\n   - Check that branding and logo usage is consistent throughout documentation\n\n4. **Command Documentation Testing**:\n   - Review each command documentation page for completeness\n   - Test all command examples by executing them in a test environment\n   - Verify output examples match actual command output\n   - Check that all command options and flags are documented\n\n5. **GitHub Pages Deployment Testing**:\n   - Make a small change to a documentation file and push to trigger the workflow\n   - Verify GitHub Actions workflow runs successfully\n   - Check that documentation is properly deployed to GitHub Pages\n   - Test the deployed site for functionality and appearance\n   - Verify custom domain configuration if applicable\n   - Confirm logo displays correctly on the deployed site\n\n6. **Content Quality Testing**:\n   - Run spell check on all documentation files\n   - Validate all external links\n   - Review documentation for consistent tone and style\n   - Verify documentation version matches current code release\n   - Have at least one team member review the documentation for clarity and completeness\n\n7. **User Experience Testing**:\n   - Test documentation on different browsers (Chrome, Firefox, Safari)\n   - Test on mobile devices\n   - Verify print functionality works correctly\n   - Test documentation search with various search terms\n\n8. **Logo Testing**:\n   - Verify logo file exists at `docs/bamon_logo.png`\n   - Check logo quality and resolution on different devices\n   - Test logo appearance in both light and dark themes (if applicable)\n   - Verify logo is responsive and scales appropriately on mobile devices\n   - Ensure favicon displays correctly in browser tabs",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement BAMON Log CLI Command",
        "description": "Create a CLI command for viewing and managing daemon log files with support for displaying, filtering, following in real-time, searching, and showing log file information.",
        "details": "1. Create a new command file `log_command.sh` in the commands directory with the following features:\n\n   a. **Basic log viewing functionality**:\n      - Display the most recent log entries (default 50 lines)\n      - Support for specifying number of lines to display with `--lines` or `-n` flag\n      - Format output with timestamps, log levels, and messages clearly displayed\n      - Handle both daemon logs and execution logs\n\n   b. **Real-time log following (tail -f functionality)**:\n      - Implement `--follow` or `-f` flag to continuously display new log entries\n      - Include proper handling of SIGINT (Ctrl+C) to exit follow mode gracefully\n      - Display timestamp for each new entry in follow mode\n\n   c. **Log filtering capabilities**:\n      - Filter by log level with `--level` flag (ERROR, WARN, INFO, DEBUG)\n      - Support for multiple levels with comma separation (e.g., `--level ERROR,WARN`)\n      - Implement `--since` flag to show logs after a specific time (e.g., \"1h\", \"2d\", \"2023-01-01\")\n      - Add `--until` flag for specifying end time for log display\n\n   d. **Search functionality**:\n      - Implement `--search` or `-s` flag for keyword/pattern searching\n      - Support for regular expression patterns with `--regex` flag\n      - Add context options (`--before` and `--after`) to show lines before/after matches\n      - Highlight matching terms in the output\n\n   e. **Log file information**:\n      - Add `--info` flag to display log file location, size, creation date\n      - Show log rotation information and available log archives\n      - Include disk usage statistics for log directory\n\n   f. **Output formatting options**:\n      - Support for different output formats (text, JSON) with `--format` flag\n      - Color-coded output based on log level (ERROR in red, WARN in yellow, etc.)\n      - Option to disable colors with `--no-color` flag\n\n2. Update the main CLI command parser to include the new log command:\n   - Add log command to the command list in `bamon.sh`\n   - Include help text and usage examples\n\n3. Integrate with the existing logging system:\n   - Use functions from `logging.sh` to access and parse log files\n   - Ensure compatibility with the log rotation functionality\n   - Handle different log file formats and structures\n\n4. Implement error handling:\n   - Gracefully handle missing or corrupted log files\n   - Provide helpful error messages when logs cannot be accessed\n   - Check for necessary permissions to read log files\n\n5. Add documentation:\n   - Update help text with detailed usage examples\n   - Document all available flags and options\n   - Include examples for common troubleshooting scenarios",
        "testStrategy": "1. **Basic functionality tests**:\n   - Verify the command displays the default number of log lines correctly\n   - Test with different values for `--lines` flag\n   - Check that log entries are properly formatted with timestamps and log levels\n   - Verify both daemon and execution logs can be viewed\n\n2. **Real-time following tests**:\n   - Test `--follow` flag and verify new log entries appear in real-time\n   - Verify that Ctrl+C properly exits follow mode\n   - Generate log entries while in follow mode to confirm they appear\n   - Test follow mode with filtering options enabled\n\n3. **Filtering tests**:\n   - Test filtering by each log level (ERROR, WARN, INFO, DEBUG)\n   - Verify multiple level filtering works correctly\n   - Test `--since` flag with various time formats (1h, 2d, YYYY-MM-DD)\n   - Verify `--until` flag correctly limits the end time of displayed logs\n   - Combine multiple filters and verify they work together correctly\n\n4. **Search functionality tests**:\n   - Test searching for various keywords and patterns\n   - Verify regex search works with different patterns\n   - Test context options (`--before` and `--after`) with different values\n   - Verify highlighting of matching terms works correctly\n   - Test search with follow mode enabled\n\n5. **Log information tests**:\n   - Verify `--info` flag displays correct file location and size\n   - Check that log rotation information is accurate\n   - Test with both existing and non-existing log files\n\n6. **Output formatting tests**:\n   - Verify color coding works correctly for different log levels\n   - Test `--no-color` flag disables all color output\n   - Verify JSON output format is valid and contains all necessary information\n   - Test all formatting options with various filtering and search options\n\n7. **Error handling tests**:\n   - Test behavior when log files are missing\n   - Verify appropriate error messages when permission is denied\n   - Test with corrupted log files to ensure graceful handling\n\n8. **Integration tests**:\n   - Verify the log command works correctly after daemon restart\n   - Test with log rotation occurring during command execution\n   - Verify compatibility with different log formats",
        "status": "done",
        "dependencies": [
          26
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create log_command.sh file structure and argument parsing",
            "description": "Set up the basic structure of the log_command.sh file with argument parsing for all required flags and options",
            "dependencies": [],
            "details": "Create the log_command.sh file in the commands directory with proper shebang and imports. Implement getopts or similar to parse all command-line arguments including: --lines/-n, --follow/-f, --level, --since, --until, --search/-s, --regex, --before, --after, --info, --format, and --no-color. Set up default values for all parameters and implement basic help text display.",
            "status": "done",
            "testStrategy": "Test argument parsing with various combinations of flags. Verify help text is displayed correctly. Test error handling for invalid arguments and combinations."
          },
          {
            "id": 2,
            "title": "Implement basic log viewing functionality",
            "description": "Create functions to display log entries with proper formatting and support for specifying the number of lines",
            "dependencies": [
              "36.1"
            ],
            "details": "Implement functions to read and display log files with proper formatting. Support displaying the most recent log entries (default 50 lines) with the --lines/-n flag. Format output to clearly show timestamps, log levels, and messages. Create functions to handle both daemon logs and execution logs from their respective locations.",
            "status": "done",
            "testStrategy": "Test displaying logs with default line count. Test with different values for --lines flag. Verify formatting is correct with timestamps and log levels. Test with both daemon and execution logs."
          },
          {
            "id": 3,
            "title": "Implement real-time log following functionality",
            "description": "Add support for continuously displaying new log entries (tail -f functionality)",
            "dependencies": [
              "36.2"
            ],
            "details": "Implement the --follow/-f flag to continuously display new log entries as they are added to the log file. Use tail -f or similar approach. Add proper handling of SIGINT (Ctrl+C) to exit follow mode gracefully. Ensure timestamps are displayed for each new entry in follow mode.",
            "status": "done",
            "testStrategy": "Test follow mode by generating new log entries while following. Verify Ctrl+C exits gracefully. Test with different log files and verify new entries appear in real-time."
          },
          {
            "id": 4,
            "title": "Implement log filtering capabilities",
            "description": "Add support for filtering logs by level and time range",
            "dependencies": [
              "36.2"
            ],
            "details": "Implement the --level flag to filter logs by severity level (ERROR, WARN, INFO, DEBUG). Support multiple levels with comma separation. Add --since flag to show logs after a specific time (supporting formats like '1h', '2d', '2023-01-01'). Implement --until flag for specifying end time for log display. Ensure filters can be combined.",
            "status": "done",
            "testStrategy": "Test filtering by single and multiple log levels. Test time-based filtering with various formats. Verify combinations of filters work correctly. Test edge cases like empty results."
          },
          {
            "id": 5,
            "title": "Implement search functionality",
            "description": "Add support for searching logs by keywords and regular expressions",
            "dependencies": [
              "36.2"
            ],
            "details": "Implement the --search/-s flag for keyword/pattern searching in log files. Add support for regular expression patterns with the --regex flag. Implement context options (--before and --after) to show lines before/after matches. Add highlighting for matching terms in the output.",
            "status": "done",
            "testStrategy": "Test keyword searching with various terms. Test regex searching with simple and complex patterns. Verify context lines are displayed correctly. Test highlighting of matching terms."
          },
          {
            "id": 6,
            "title": "Implement log file information display",
            "description": "Add functionality to display metadata about log files",
            "dependencies": [
              "36.1"
            ],
            "details": "Implement the --info flag to display log file metadata including location, size, and creation date. Show log rotation information and available log archives. Include disk usage statistics for the log directory. Format the information in a clear, readable way.",
            "status": "done",
            "testStrategy": "Test info display for various log files. Verify all metadata is accurate. Test with rotated logs to ensure archive information is correct. Verify disk usage statistics match system values."
          },
          {
            "id": 7,
            "title": "Implement output formatting options",
            "description": "Add support for different output formats and color coding",
            "dependencies": [
              "36.2",
              "36.4",
              "36.5"
            ],
            "details": "Implement the --format flag to support different output formats (text, JSON). Add color-coded output based on log level (ERROR in red, WARN in yellow, etc.). Implement the --no-color flag to disable colors. Ensure all output formatting is consistent across different command options.",
            "status": "done",
            "testStrategy": "Test text and JSON output formats. Verify color coding works correctly for different log levels. Test --no-color flag disables all colors. Test formatting with various combinations of other flags."
          },
          {
            "id": 8,
            "title": "Implement error handling and integrate with main CLI",
            "description": "Add robust error handling and integrate the log command with the main BAMON CLI",
            "dependencies": [
              "36.1",
              "36.2",
              "36.3",
              "36.4",
              "36.5",
              "36.6",
              "36.7"
            ],
            "details": "Implement error handling for missing or corrupted log files, permission issues, and invalid arguments. Provide helpful error messages when logs cannot be accessed. Update the main CLI command parser in bamon.sh to include the new log command. Add comprehensive help text and usage examples. Test integration with the existing logging system and log rotation functionality.",
            "status": "done",
            "testStrategy": "Test error handling with missing files, permission issues, and corrupted logs. Verify helpful error messages are displayed. Test integration with main CLI. Verify help text is comprehensive and accurate."
          },
          {
            "id": 9,
            "title": "Create comprehensive tests for log command functionality",
            "description": "Create test cases for all log command features including basic viewing, filtering, searching, real-time following, JSON output, and error handling",
            "details": "Create test files in test/commands/ directory to test:\n1. Basic log viewing with --lines flag\n2. Level filtering with --level flag (single and multiple levels)\n3. Search functionality with --search flag (keyword and regex)\n4. Real-time following with --follow flag\n5. JSON output format with --format json\n6. Log file information with --info flag\n7. Error handling for missing log files\n8. Context lines with --before and --after flags\n9. No-color output with --no-color flag\n10. Integration with existing test framework",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 36
          }
        ]
      },
      {
        "id": 37,
        "title": "Integrate Documentation Deployment into Release Workflow",
        "description": "Modify the documentation system to keep the build process in a separate workflow while moving deployment to the release workflow, and ensure the application version is embedded and visible in the generated documentation.",
        "details": "1. **Maintain Existing Documentation Build Workflow**:\n   - Keep the existing GitHub Actions workflow that builds documentation on changes to the docs folder\n   - Modify it to store the built documentation as an artifact that can be used by other workflows\n   - Add a step to generate a version information file during the build process\n   - Example workflow modification:\n     ```yaml\n     name: Build Documentation\n     \n     on:\n       push:\n         paths:\n           - 'docs/**'\n           - 'mkdocs.yml'\n     \n     jobs:\n       build:\n         runs-on: ubuntu-latest\n         steps:\n           - uses: actions/checkout@v3\n             with:\n               fetch-depth: 0\n           \n           - name: Set up Python\n             uses: actions/setup-python@v4\n             with:\n               python-version: '3.10'\n           \n           - name: Install dependencies\n             run: |\n               python -m pip install --upgrade pip\n               pip install mkdocs-material\n               # Install any other required packages\n           \n           - name: Extract version information\n             id: version\n             run: |\n               VERSION=$(cat VERSION || echo \"development\")\n               echo \"VERSION=$VERSION\" >> $GITHUB_ENV\n           \n           - name: Generate version info file\n             run: |\n               echo \"version: $VERSION\" > docs/version_info.md\n               echo \"build_date: $(date -u +'%Y-%m-%d %H:%M:%S UTC')\" >> docs/version_info.md\n               echo \"commit: $(git rev-parse --short HEAD)\" >> docs/version_info.md\n           \n           - name: Build documentation\n             run: mkdocs build\n           \n           - name: Upload documentation artifact\n             uses: actions/upload-artifact@v3\n             with:\n               name: documentation\n               path: site/\n               retention-days: 7\n     ```\n\n2. **Update MkDocs Configuration**:\n   - Modify `mkdocs.yml` to include version information at the beginning of the documentation\n   - Add a version display in the navigation or header section\n   - Example configuration changes:\n     ```yaml\n     # Add to mkdocs.yml\n     extra:\n       version:\n         provider: mike\n         default: latest\n     \n     markdown_extensions:\n       - meta\n       - admonition\n     \n     nav:\n       - Home: index.md\n       - Version Info: version_info.md\n       # Other navigation items\n     ```\n\n3. **Create Documentation Template with Version Display**:\n   - Update the main documentation template to prominently display version information\n   - Add to the main.html or home.html template in the docs theme:\n     ```html\n     {% if config.extra.version %}\n     <div class=\"md-version\">\n       <span class=\"md-version__current\">Version: {{ config.extra.version }}</span>\n     </div>\n     {% endif %}\n     ```\n\n4. **Modify Release Workflow to Deploy Documentation**:\n   - Update the release.yml workflow to include a documentation deployment step\n   - Download the documentation artifact from the most recent successful build\n   - Deploy to GitHub Pages as part of the release process\n   - Example workflow modification:\n     ```yaml\n     name: Release\n     \n     on:\n       workflow_dispatch:\n         inputs:\n           version:\n             description: 'Version to release'\n             required: true\n     \n     jobs:\n       # Existing release jobs...\n       \n       deploy-docs:\n         runs-on: ubuntu-latest\n         needs: [release] # Make sure this runs after the main release job\n         steps:\n           - uses: actions/checkout@v3\n           \n           - name: Download documentation artifact\n             uses: actions/download-artifact@v3\n             with:\n               name: documentation\n               path: site\n           \n           - name: Deploy to GitHub Pages\n             uses: peaceiris/actions-gh-pages@v3\n             with:\n               github_token: ${{ secrets.GITHUB_TOKEN }}\n               publish_dir: ./site\n               force_orphan: true\n               commit_message: \"Deploy documentation for version ${{ github.event.inputs.version }}\"\n         \n     ```\n\n5. **Fallback Documentation Build in Release Workflow**:\n   - Add a conditional step in the release workflow to build documentation if no artifact is available\n   - This ensures documentation is always deployed even if the separate build workflow hasn't run recently\n   - Example:\n     ```yaml\n     - name: Check for documentation artifact\n       id: check_artifact\n       run: |\n         if [ -d \"site\" ] && [ \"$(ls -A site)\" ]; then\n           echo \"artifact_exists=true\" >> $GITHUB_OUTPUT\n         else\n           echo \"artifact_exists=false\" >> $GITHUB_OUTPUT\n         fi\n     \n     - name: Build documentation if needed\n       if: steps.check_artifact.outputs.artifact_exists != 'true'\n       run: |\n         python -m pip install --upgrade pip\n         pip install mkdocs-material\n         # Generate version info\n         echo \"version: ${{ github.event.inputs.version }}\" > docs/version_info.md\n         echo \"build_date: $(date -u +'%Y-%m-%d %H:%M:%S UTC')\" >> docs/version_info.md\n         echo \"commit: $(git rev-parse --short HEAD)\" >> docs/version_info.md\n         # Build docs\n         mkdocs build\n     ```\n\n6. **Update Documentation README**:\n   - Update the documentation README to explain the new build and deployment process\n   - Include information about how version information is now included in the docs",
        "testStrategy": "1. **Test Documentation Build Workflow**:\n   - Make a change to a file in the docs directory\n   - Push the change and verify the build workflow triggers\n   - Check that the documentation builds successfully\n   - Verify the artifact is created and contains the complete site directory\n   - Confirm the version information file is generated correctly\n\n2. **Test Version Information Display**:\n   - Build the documentation locally with different version values\n   - Verify the version information appears at the beginning of the documentation\n   - Check that the version is displayed correctly in the navigation or header\n   - Ensure the version information page contains all required details (version, build date, commit)\n\n3. **Test Release Workflow Documentation Deployment**:\n   - Trigger a manual release with a specific version\n   - Verify the release workflow downloads the documentation artifact\n   - Confirm the documentation is deployed to GitHub Pages\n   - Check that the deployed documentation shows the correct version information\n   - Verify all links and resources work correctly in the deployed documentation\n\n4. **Test Fallback Documentation Build**:\n   - Delete any existing documentation artifacts\n   - Trigger a release\n   - Verify the workflow detects missing artifacts and builds documentation\n   - Confirm the built documentation is deployed correctly\n   - Check that version information is still included\n\n5. **Test Workflow Dependencies and Timing**:\n   - Verify the documentation deployment step runs after the main release steps\n   - Confirm that documentation deployment doesn't block or delay the main release process\n   - Test that a failed documentation deployment doesn't cause the entire release to fail\n\n6. **Cross-Browser Testing**:\n   - Check the deployed documentation with version information in multiple browsers\n   - Verify the version display is visible and correctly formatted on mobile devices\n   - Test the documentation site's responsiveness with the added version information",
        "status": "done",
        "dependencies": [
          33,
          35
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Modify Existing Documentation Build Workflow",
            "description": "Update the GitHub Actions workflow to build documentation and store it as an artifact for use by other workflows.",
            "dependencies": [],
            "details": "- Modify the existing GitHub Actions workflow that builds documentation on changes to the docs folder\n- Add steps to store the built documentation as an artifact with a 7-day retention period\n- Implement version information extraction from the VERSION file\n- Create a version_info.md file during the build process containing version, build date, and commit hash\n- Ensure the workflow runs on changes to docs/** and mkdocs.yml",
            "status": "done",
            "testStrategy": "- Make a change to a file in the docs directory\n- Push the change and verify the build workflow triggers\n- Check that the documentation builds successfully\n- Verify the artifact is created and contains the complete site directory\n- Confirm the version_info.md file is generated with correct information"
          },
          {
            "id": 2,
            "title": "Update MkDocs Configuration for Version Display",
            "description": "Modify the MkDocs configuration to include and display version information throughout the documentation.",
            "dependencies": [
              "37.1"
            ],
            "details": "- Update mkdocs.yml to include version information configuration\n- Add version provider settings in the extra section\n- Configure markdown extensions to support meta and admonition\n- Add version_info.md to the navigation structure\n- Ensure the configuration properly references the version information file",
            "status": "done",
            "testStrategy": "- Build the documentation locally to verify configuration changes\n- Check that version information appears in the navigation\n- Verify that the version_info.md page is accessible\n- Ensure the configuration doesn't break existing documentation features"
          },
          {
            "id": 3,
            "title": "Create Documentation Template with Version Display",
            "description": "Update the main documentation template to prominently display version information in the UI.",
            "dependencies": [
              "37.2"
            ],
            "details": "- Create or modify the main.html or home.html template in the docs theme\n- Add HTML/template code to display version information prominently\n- Implement conditional display based on version availability\n- Style the version display to be visible but not intrusive\n- Ensure compatibility with the MkDocs Material theme",
            "status": "done",
            "testStrategy": "- Build the documentation locally to verify template changes\n- Check that version information appears correctly in the rendered documentation\n- Test with different version values to ensure proper display\n- Verify the template changes don't break responsive design"
          },
          {
            "id": 4,
            "title": "Implement Documentation Deployment in Release Workflow",
            "description": "Update the release.yml workflow to include steps for deploying documentation to GitHub Pages.",
            "dependencies": [
              "37.1"
            ],
            "details": "- Modify the release.yml workflow to add a documentation deployment job\n- Configure the job to run after the main release job completes\n- Add steps to download the documentation artifact built by the separate workflow\n- Implement GitHub Pages deployment using peaceiris/actions-gh-pages action\n- Configure deployment with appropriate settings (force_orphan, commit message with version)",
            "status": "done",
            "testStrategy": "- Trigger a test release workflow\n- Verify the documentation deployment job runs after the main release job\n- Check that the artifact is correctly downloaded\n- Confirm the documentation is successfully deployed to GitHub Pages\n- Verify the deployed documentation shows the correct version information"
          },
          {
            "id": 5,
            "title": "Create Fallback Documentation Build in Release Workflow",
            "description": "Add conditional steps in the release workflow to build documentation if no artifact is available.",
            "dependencies": [
              "37.4"
            ],
            "details": "- Add a step to check if the documentation artifact exists and is not empty\n- Implement conditional logic to build documentation if the artifact is missing\n- Install required dependencies (mkdocs-material and other packages)\n- Generate version_info.md with the release version\n- Build documentation using mkdocs build command\n- Ensure this fallback process uses the same version information as the main build",
            "status": "done",
            "testStrategy": "- Test the release workflow without a pre-built documentation artifact\n- Verify the fallback build process executes correctly\n- Check that the documentation is built with the correct version information\n- Confirm the fallback-built documentation deploys successfully to GitHub Pages"
          },
          {
            "id": 6,
            "title": "Update Documentation README and Process Documentation",
            "description": "Update the documentation README and process documentation to explain the new build and deployment workflow.",
            "dependencies": [
              "37.4",
              "37.5"
            ],
            "details": "- Update the documentation README to explain the new build and deployment process\n- Document how version information is included in the documentation\n- Explain the separation between build and deployment workflows\n- Provide information on how to manually trigger documentation builds\n- Include troubleshooting steps for common issues",
            "status": "done",
            "testStrategy": "- Review the updated README for clarity and completeness\n- Verify all documented processes match the implemented workflows\n- Check that troubleshooting steps are accurate\n- Ensure the documentation is understandable for new contributors"
          },
          {
            "id": 7,
            "title": "Implement Version Badge in Documentation",
            "description": "Add a version badge to the documentation that clearly displays the current version of the application.",
            "dependencies": [
              "37.2",
              "37.3"
            ],
            "details": "- Design a version badge that displays the current application version\n- Add the badge to the documentation homepage and/or header\n- Ensure the badge is updated automatically when the version changes\n- Style the badge to be visually distinct and easily noticeable\n- Make the badge link to the version history or release notes if available",
            "status": "done",
            "testStrategy": "- Build documentation with different version values\n- Verify the badge displays the correct version\n- Check that the badge is visible on different screen sizes\n- Confirm the badge links to the appropriate page if configured"
          },
          {
            "id": 8,
            "title": "Test and Validate Complete Documentation Workflow",
            "description": "Perform comprehensive testing of the entire documentation build and deployment process across different scenarios.",
            "dependencies": [
              "37.1",
              "37.2",
              "37.3",
              "37.4",
              "37.5",
              "37.6",
              "37.7"
            ],
            "details": "- Test the complete workflow from documentation changes to deployment\n- Verify the process works when triggered by documentation changes\n- Test the process during a release workflow\n- Validate the fallback build process works correctly\n- Ensure version information is correctly displayed in all scenarios\n- Check that all links and navigation elements work in the deployed documentation\n- Verify the documentation is accessible and properly formatted on GitHub Pages",
            "status": "done",
            "testStrategy": "- Make changes to documentation and verify the build workflow triggers\n- Trigger a release and verify documentation deploys correctly\n- Test with and without pre-built documentation artifacts\n- Check version display in various parts of the documentation\n- Verify all pages load correctly on the deployed GitHub Pages site\n- Test on different browsers and devices to ensure responsive design"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-12T23:10:00.761Z",
      "updated": "2025-09-28T13:32:20.462Z",
      "description": "Tasks for master context"
    }
  }
}