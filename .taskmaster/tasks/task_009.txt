# Task ID: 9
# Title: Implement Start/Stop/Restart Commands
# Status: done
# Dependencies: 2, 3
# Priority: high
# Description: Create commands to start, stop, and restart the daemon process with appropriate options and error handling.
# Details:
1. Implement the start command in `src/start_command.sh`:
```bash
#!/usr/bin/env bash

source "${BASH_SOURCE%/*}/lib/config.sh"
source "${BASH_SOURCE%/*}/lib/daemon.sh"
source "${BASH_SOURCE%/*}/lib/logger.sh"

function start_command() {
  local daemon_mode=${args[--daemon]}
  local config_file=${args[--config]}
  
  # Set custom config file if specified
  if [[ -n "$config_file" ]]; then
    if [[ ! -f "$config_file" ]]; then
      echo "Error: Config file '$config_file' does not exist"
      return 1
    fi
    export CONFIG_FILE="$config_file"
  fi
  
  # Check if daemon is already running
  if is_daemon_running; then
    echo "Daemon is already running with PID $(cat "$(get_pid_file)")"
    return 1
  fi
  
  # Start daemon
  if [[ "$daemon_mode" == "true" ]]; then
    echo "Starting daemon in background..."
    start_daemon true
  else
    echo "Starting daemon in foreground (press Ctrl+C to stop)..."
    start_daemon false
  fi
  
  return 0
}
```

2. Implement the stop command in `src/stop_command.sh`:
```bash
#!/usr/bin/env bash

source "${BASH_SOURCE%/*}/lib/config.sh"
source "${BASH_SOURCE%/*}/lib/logger.sh"

function stop_command() {
  local force=${args[--force]}
  
  # Check if daemon is running
  if ! is_daemon_running; then
    echo "Daemon is not running"
    return 1
  fi
  
  local pid=$(cat "$(get_pid_file)")
  
  echo "Stopping daemon (PID: $pid)..."
  
  # Send signal to daemon
  if [[ "$force" == "true" ]]; then
    # Force kill
    kill -9 "$pid" 2>/dev/null
  else
    # Graceful shutdown
    kill -15 "$pid" 2>/dev/null
  fi
  
  # Wait for process to terminate
  local timeout=10
  local count=0
  while kill -0 "$pid" 2>/dev/null && [[ $count -lt $timeout ]]; do
    sleep 1
    ((count++))
  done
  
  # Check if process is still running
  if kill -0 "$pid" 2>/dev/null; then
    echo "Failed to stop daemon within $timeout seconds"
    echo "Use --force to forcefully terminate the process"
    return 1
  else
    echo "Daemon stopped"
    # Remove PID file if it still exists
    if [[ -f "$(get_pid_file)" ]]; then
      rm -f "$(get_pid_file)"
    fi
    return 0
  fi
}
```

3. Implement the restart command in `src/restart_command.sh`:
```bash
#!/usr/bin/env bash

source "${BASH_SOURCE%/*}/lib/config.sh"

function restart_command() {
  local daemon_mode=${args[--daemon]}
  local config_file=${args[--config]}
  
  # Stop daemon if running
  if is_daemon_running; then
    echo "Stopping daemon..."
    "$0" stop
    
    # Check if stop was successful
    if [[ $? -ne 0 ]]; then
      echo "Failed to stop daemon, cannot restart"
      return 1
    fi
  fi
  
  # Start daemon again
  echo "Starting daemon..."
  
  # Build start command with appropriate options
  local start_cmd="$0 start"
  if [[ "$daemon_mode" == "true" ]]; then
    start_cmd+="--daemon"
  fi
  if [[ -n "$config_file" ]]; then
    start_cmd+=" --config '$config_file'"
  fi
  
  eval "$start_cmd"
  return $?
}
```

4. Add helper function to check if daemon is running
5. Implement proper signal handling for graceful shutdown
6. Add support for custom config file path

# Test Strategy:
1. Test starting daemon in both foreground and background modes
2. Verify daemon can be stopped gracefully
3. Test force stopping a daemon that doesn't respond to normal signals
4. Verify restart command correctly stops and starts the daemon
5. Test error handling when daemon is already running or not running
6. Verify custom config file option works correctly
