# Task ID: 3
# Title: Implement Daemon Core Functionality
# Status: done
# Dependencies: 2
# Priority: high
# Description: Create the core daemon functionality that runs in the background and executes scripts at specified intervals.
# Details:
1. Create `src/lib/daemon.sh` with core daemon functions:
```bash
#!/usr/bin/env bash

source "${BASH_SOURCE%/*}/config.sh"
source "${BASH_SOURCE%/*}/logger.sh"

# Start daemon process
function start_daemon() {
  local daemon_mode=$1
  load_config
  
  # Check if daemon is already running
  if is_daemon_running; then
    echo "Daemon is already running with PID $(cat "$(get_pid_file)")"
    return 1
  fi
  
  # If daemon mode, fork to background
  if [[ "$daemon_mode" == "true" ]]; then
    nohup "$0" daemon_run > /dev/null 2>&1 &
    echo $! > "$(get_pid_file)"
    echo "Daemon started with PID $!"
  else
    # Run in foreground
    daemon_run
  fi
}

# Main daemon loop
function daemon_run() {
  log_info "Daemon started"
  
  # Set up trap for clean shutdown
  trap shutdown SIGINT SIGTERM
  
  # Main loop
  while true; do
    # Get all enabled scripts
    local scripts=$(get_enabled_scripts)
    
    # Check which scripts need to be run
    for script in $scripts; do
      if should_run_script "$script"; then
        execute_script "$script"
      fi
    done
    
    # Sleep for a short time before checking again
    sleep 5
  done
}

# Execute a script
function execute_script() {
  local script_name=$1
  local script_command=$(get_script_command "$script_name")
  local max_concurrent=$(get_max_concurrent)
  
  # Check if we're already at max concurrent executions
  local running_count=$(count_running_scripts)
  if [[ $running_count -ge $max_concurrent ]]; then
    log_warn "Max concurrent executions reached, delaying $script_name"
    return
  fi
  
  # Execute script in background with timeout
  log_info "Executing script: $script_name"
  {
    local start_time=$(date +%s)
    local output
    local exit_code
    
    # Execute with timeout
    output=$(timeout 30s bash -c "$script_command" 2>&1)
    exit_code=$?
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    # Update script status in config
    update_script_status "$script_name" "$exit_code" "$output" "$duration"
    
    if [[ $exit_code -eq 0 ]]; then
      log_info "Script $script_name completed successfully in ${duration}s"
    else
      log_error "Script $script_name failed with exit code $exit_code in ${duration}s"
      log_error "Output: $output"
    fi
  } &
}

# Check if script should be run based on its interval
function should_run_script() {
  local script_name=$1
  local last_run=$(get_script_last_run "$script_name")
  local interval=$(get_script_interval "$script_name")
  local now=$(date +%s)
  
  # If never run or interval has passed
  if [[ -z "$last_run" || $((now - last_run)) -ge $interval ]]; then
    return 0
  fi
  
  return 1
}

# Shutdown daemon gracefully
function shutdown() {
  log_info "Shutting down daemon"
  # Clean up PID file
  rm -f "$(get_pid_file)"
  exit 0
}
```
2. Implement script execution with proper timeout handling
3. Add concurrency control to limit simultaneous script executions
4. Implement interval-based execution scheduling
5. Add proper signal handling for graceful shutdown

# Test Strategy:
1. Test daemon startup in both foreground and background modes
2. Verify script execution at specified intervals
3. Test concurrent execution limits
4. Verify proper handling of script timeouts
5. Test graceful shutdown with signal handling
6. Verify PID file management
