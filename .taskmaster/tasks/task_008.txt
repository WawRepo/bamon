# Task ID: 8
# Title: Implement Now Command
# Status: done
# Dependencies: 2, 3
# Priority: medium
# Description: Create the now command to execute scripts immediately, either all enabled scripts or a specific one by name.
# Details:
1. Implement the now command in `src/now_command.sh`:
```bash
#!/usr/bin/env bash

source "${BASH_SOURCE%/*}/lib/config.sh"
source "${BASH_SOURCE%/*}/lib/logger.sh"

function now_command() {
  local name=${args[--name]}
  local async=${args[--async]}
  
  # Load config
  load_config
  
  # If specific script is specified, check if it exists
  if [[ -n "$name" ]] && ! script_exists "$name"; then
    echo "Error: Script '$name' does not exist"
    return 1
  fi
  
  # Get scripts to execute
  local scripts
  if [[ -n "$name" ]]; then
    # Check if script is enabled
    if ! is_script_enabled "$name"; then
      echo "Error: Script '$name' is disabled"
      return 1
    fi
    scripts="$name"
  else
    scripts=$(get_enabled_scripts)
    if [[ -z "$scripts" ]]; then
      echo "No enabled scripts found"
      return 0
    fi
  fi
  
  echo "Executing scripts..."
  
  # Track PIDs if running async
  local pids=()
  
  # Execute each script
  for script in $scripts; do
    echo "Running '$script'..."
    
    local command=$(get_script_command "$script")
    local start_time=$(date +%s)
    
    if [[ "$async" == "true" ]]; then
      # Run in background
      {
        local output
        local exit_code
        
        output=$(bash -c "$command" 2>&1)
        exit_code=$?
        
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        
        # Update script status
        update_script_status "$script" "$exit_code" "$output" "$duration"
        
        # Print result
        if [[ $exit_code -eq 0 ]]; then
          echo "'$script' completed successfully in ${duration}s"
        else
          echo "'$script' failed with exit code $exit_code in ${duration}s"
          echo "Output: $output"
        fi
      } &
      
      pids+=($!)
    else
      # Run synchronously
      local output
      local exit_code
      
      output=$(bash -c "$command" 2>&1)
      exit_code=$?
      
      local end_time=$(date +%s)
      local duration=$((end_time - start_time))
      
      # Update script status
      update_script_status "$script" "$exit_code" "$output" "$duration"
      
      # Print result
      if [[ $exit_code -eq 0 ]]; then
        echo "'$script' completed successfully in ${duration}s"
      else
        echo "'$script' failed with exit code $exit_code in ${duration}s"
        echo "Output: $output"
      fi
    fi
  done
  
  # If async, wait for all processes to complete
  if [[ "$async" == "true" ]] && [[ ${#pids[@]} -gt 0 ]]; then
    echo "Waiting for all scripts to complete..."
    for pid in "${pids[@]}"; do
      wait "$pid"
    done
    echo "All scripts completed"
  fi
  
  return 0
}
```
2. Implement script execution with proper output capture
3. Add support for executing a specific script by name
4. Implement asynchronous execution option
5. Update script status after execution
6. Provide real-time feedback on execution results

# Test Strategy:
1. Test executing all enabled scripts
2. Test executing a specific script by name
3. Verify error handling for non-existent scripts
4. Test asynchronous execution with multiple scripts
5. Verify script status is updated after execution
6. Test execution of scripts with different exit codes
