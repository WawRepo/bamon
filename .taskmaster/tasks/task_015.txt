# Task ID: 15
# Title: Implement Status Check Command
# Status: pending
# Dependencies: 2, 5, 10
# Priority: high
# Description: Create a command to check the last execution status of all scripts without running them, showing execution history and scheduled information.
# Details:
1. Create `src/status_check_command.sh` to implement the status check functionality:
```bash
#!/usr/bin/env bash

source "${BASH_SOURCE%/*}/lib/config.sh"
source "${BASH_SOURCE%/*}/lib/logger.sh"

function status_check_command() {
  local name=${args[--name]}
  local json_output=${args[--json]}
  
  # Load config
  load_config
  
  # Get all scripts or specific script
  local scripts=""
  if [[ -n "$name" ]]; then
    if ! script_exists "$name"; then
      echo "Error: Script '$name' does not exist"
      return 1
    fi
    scripts="$name"
  else
    scripts=$(get_all_scripts)
    if [[ -z "$scripts" ]]; then
      echo "No scripts configured. Use 'bamon add' to add scripts."
      return 0
    fi
  fi
  
  # Print header if not JSON output
  if [[ "$json_output" != "true" ]]; then
    printf "%-20s %-20s %-10s %-15s %-20s %-20s %s\n" "NAME" "LAST EXECUTION" "RESULT" "DURATION" "TIME SINCE" "NEXT EXECUTION" "ERROR"
    printf "%s\n" "$(printf '=%.0s' {1..120})"
  else
    echo "{"
    echo "  \"scripts\": ["
  fi
  
  local first=true
  for script in $scripts; do
    # Get script details
    local enabled=$(get_script_property "$script" "enabled")
    local last_run=$(get_script_property "$script" "last_run")
    local last_status=$(get_script_property "$script" "last_status")
    local last_duration=$(get_script_property "$script" "last_duration")
    local last_error=$(get_script_property "$script" "last_error")
    local interval=$(get_script_property "$script" "interval")
    
    # Calculate time since last execution
    local time_since="Never"
    if [[ -n "$last_run" && "$last_run" != "null" ]]; then
      local now=$(date +%s)
      local last_run_seconds=$(date -d "$last_run" +%s 2>/dev/null || date -j -f "%Y-%m-%d %H:%M:%S" "$last_run" +%s 2>/dev/null)
      local seconds_diff=$((now - last_run_seconds))
      
      if [[ $seconds_diff -lt 60 ]]; then
        time_since="${seconds_diff}s ago"
      elif [[ $seconds_diff -lt 3600 ]]; then
        time_since="$((seconds_diff / 60))m ago"
      elif [[ $seconds_diff -lt 86400 ]]; then
        time_since="$((seconds_diff / 3600))h ago"
      else
        time_since="$((seconds_diff / 86400))d ago"
      fi
    fi
    
    # Calculate next execution time
    local next_execution="Not scheduled"
    if [[ "$enabled" == "true" && -n "$last_run" && "$last_run" != "null" && -n "$interval" ]]; then
      # Parse interval (e.g., 1h, 30m, 1d)
      local interval_value=${interval%[hmd]*}
      local interval_unit=${interval#$interval_value}
      
      local seconds_to_add=0
      case "$interval_unit" in
        m) seconds_to_add=$((interval_value * 60)) ;;
        h) seconds_to_add=$((interval_value * 3600)) ;;
        d) seconds_to_add=$((interval_value * 86400)) ;;
      esac
      
      local next_run_seconds=$((last_run_seconds + seconds_to_add))
      local next_run_date=$(date -d "@$next_run_seconds" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || date -r "$next_run_seconds" "+%Y-%m-%d %H:%M:%S" 2>/dev/null)
      
      # Check if next execution is in the past or future
      if [[ $next_run_seconds -lt $now ]]; then
        next_execution="Overdue (${next_run_date})"
      else
        local time_until=$((next_run_seconds - now))
        if [[ $time_until -lt 60 ]]; then
          next_execution="In ${time_until}s"
        elif [[ $time_until -lt 3600 ]]; then
          next_execution="In $((time_until / 60))m"
        elif [[ $time_until -lt 86400 ]]; then
          next_execution="In $((time_until / 3600))h"
        else
          next_execution="In $((time_until / 86400))d"
        fi
      fi
    elif [[ "$enabled" != "true" ]]; then
      next_execution="Disabled"
    fi
    
    # Format result
    local result="Unknown"
    if [[ -n "$last_status" ]]; then
      if [[ "$last_status" == "0" ]]; then
        result="Success"
      else
        result="Failed"
      fi
    fi
    
    # Format duration
    local duration="N/A"
    if [[ -n "$last_duration" && "$last_duration" != "null" ]]; then
      if [[ $last_duration -lt 1 ]]; then
        duration="<1s"
      elif [[ $last_duration -lt 60 ]]; then
        duration="${last_duration}s"
      elif [[ $last_duration -lt 3600 ]]; then
        duration="$((last_duration / 60))m $((last_duration % 60))s"
      else
        duration="$((last_duration / 3600))h $((last_duration / 60 % 60))m"
      fi
    fi
    
    # Truncate error message if too long
    local error_msg=""
    if [[ -n "$last_error" && "$last_error" != "null" ]]; then
      if [[ ${#last_error} -gt 30 ]]; then
        error_msg="${last_error:0:27}..."
      else
        error_msg="$last_error"
      fi
    fi
    
    # Output in requested format
    if [[ "$json_output" == "true" ]]; then
      if [[ "$first" != "true" ]]; then
        echo "    ,"
      fi
      first=false
      
      echo "    {"
      echo "      \"name\": \"$script\","
      echo "      \"lastExecution\": \"${last_run:-null}\","
      echo "      \"result\": \"$result\","
      echo "      \"duration\": \"$duration\","
      echo "      \"timeSince\": \"$time_since\","
      echo "      \"nextExecution\": \"$next_execution\","
      echo "      \"error\": \"${last_error:-null}\""
      echo -n "    }"
    else
      printf "%-20s %-20s %-10s %-15s %-20s %-20s %s\n" \
        "$script" \
        "${last_run:-Never}" \
        "$result" \
        "$duration" \
        "$time_since" \
        "$next_execution" \
        "$error_msg"
    fi
  done
  
  if [[ "$json_output" == "true" ]]; then
    echo ""
    echo "  ]"
    echo "}"
  fi
}
```

2. Update `src/main.sh` to include the new command:
```bash
# Add to the command list
commands["status-check"]="Check the last execution status of all scripts without running them"

# Add to the command handler
elif [[ "$command" == "status-check" ]]; then
  source "${BASH_SOURCE%/*}/status_check_command.sh"
  status_check_command
```

3. Add command-line options in the help text:
```bash
  status-check [--name SCRIPT_NAME] [--json]
    Check the last execution status of all scripts without running them
    Options:
      --name SCRIPT_NAME  Check status of a specific script
      --json              Output in JSON format
```

4. Ensure the status check command reads from the execution history stored in the configuration file, without triggering any new executions.

5. Implement proper error handling for cases where scripts have never been executed or where execution data is incomplete.

6. Add cross-platform compatibility for date calculations to ensure the command works on both Linux and macOS.

# Test Strategy:
1. Test status check command with no scripts configured:
   - Verify appropriate message is displayed
   - Check exit code is 0

2. Test with multiple scripts in different states:
   - Scripts that have never run
   - Scripts that succeeded in their last run
   - Scripts that failed in their last run
   - Disabled scripts
   - Scripts with different interval settings

3. Test filtering for a specific script:
   - Verify correct output when script exists
   - Verify error handling when script doesn't exist

4. Test JSON output format:
   - Ensure valid JSON is produced
   - Verify all fields are correctly populated
   - Test with both single script and multiple scripts

5. Verify time calculations:
   - Test with scripts run at different times (just now, minutes ago, hours ago, days ago)
   - Verify "time since last execution" is calculated correctly
   - Verify "next scheduled execution" is calculated correctly for different intervals

6. Test cross-platform compatibility:
   - Verify the command works correctly on both Linux and macOS
   - Test date calculations on both platforms

7. Test with edge cases:
   - Scripts with very long error messages
   - Scripts with extremely short or long execution durations
   - Scripts with unusual interval settings

# Subtasks:
## 1. Implement core status check functionality [pending]
### Dependencies: None
### Description: Create the main status_check_command function that retrieves execution status for all scripts or a specific script
### Details:
Implement the core functionality in src/status_check_command.sh that loads configuration, retrieves script execution data, and handles the --name parameter to filter for a specific script. Include proper error handling for non-existent scripts and empty script lists.

## 2. Implement status formatting and display logic [pending]
### Dependencies: 15.1
### Description: Create the formatting logic for displaying script execution status in both human-readable and JSON formats
### Details:
Implement the display logic that formats execution status information including last execution time, result (success/failure), duration, time since last run, next scheduled execution, and error messages. Support both human-readable tabular output and structured JSON output based on the --json flag.

## 3. Implement time calculation functions [pending]
### Dependencies: 15.1
### Description: Create cross-platform compatible functions for date/time calculations to determine time since last run and next execution
### Details:
Implement functions that calculate time differences and format them in a human-readable way (e.g., '5m ago', 'In 2h'). Ensure compatibility with both Linux (date -d) and macOS (date -j) date commands. Handle edge cases like scripts that have never run or are disabled.

## 4. Integrate status check command with main CLI [pending]
### Dependencies: 15.1, 15.2
### Description: Update src/main.sh to include the new status-check command and its help text
### Details:
Add the status-check command to the commands array in src/main.sh. Include the command in the help text with proper documentation of the --name and --json options. Update the command handler to source the status_check_command.sh file and call the status_check_command function.

## 5. Implement Enhanced Status Check Command with JSON Support [pending]
### Dependencies: 15.5, 15.3, 15.4
### Description: Create a comprehensive status check command that displays detailed execution results for all monitored scripts with support for JSON output format, filtering options, and execution history storage.
### Details:
1. Extend the existing status command in `src/status_command.sh` to include detailed execution information:

```bash
#!/usr/bin/env bash

source "${BASH_SOURCE%/*}/lib/config.sh"
source "${BASH_SOURCE%/*}/lib/logger.sh"

function status_command() {
  local verbose=${args[--verbose]}
  local failed_only=${args[--failed-only]}
  local json_output=${args[--json]}
  local history_file=$(get_history_file_path)
  
  # Load config
  load_config
  
  # Prepare data structure for output
  declare -A status_data
  status_data["daemon_status"]=$(is_daemon_running && echo "RUNNING" || echo "STOPPED")
  
  if is_daemon_running; then
    status_data["daemon_pid"]=$(cat "$(get_pid_file)")
  fi
  
  # Get all scripts
  local scripts=$(get_all_scripts)
  
  # Prepare scripts array
  declare -a script_entries
  
  # Process each script
  for script in $scripts; do
    local enabled=$(is_script_enabled "$script" && echo "true" || echo "false")
    local last_run=$(get_script_last_run "$script")
    local last_status=$(get_script_last_status "$script")
    local exit_code=$(get_script_exit_code "$script")
    local execution_time=$(get_script_execution_time "$script")
    local stdout=$(get_script_stdout "$script")
    local stderr=$(get_script_stderr "$script")
    
    # Skip if failed_only is set and script didn't fail
    if [[ "$failed_only" == "true" && "$last_status" != "FAILED" ]]; then
      continue
    fi
    
    # Create script entry
    local script_entry=$(create_script_entry "$script" "$enabled" "$last_run" "$last_status" "$exit_code" "$execution_time" "$stdout" "$stderr")
    script_entries+=("$script_entry")
  done
  
  # Output in requested format
  if [[ "$json_output" == "true" ]]; then
    output_json_format "$(get_daemon_status)" "${script_entries[@]}"
  else
    output_text_format "$(get_daemon_status)" "${script_entries[@]}" "$verbose"
  fi
  
  # Store execution history
  store_execution_history "${script_entries[@]}"
  
  return 0
}

# Create a structured script entry
function create_script_entry() {
  local script=$1
  local enabled=$2
  local last_run=$3
  local last_status=$4
  local exit_code=$5
  local execution_time=$6
  local stdout=$7
  local stderr=$8
  
  # Create JSON-like structure
  echo "{\"name\":\"$script\",\"enabled\":$enabled,\"last_run\":\"$last_run\",\"status\":\"$last_status\",\"exit_code\":$exit_code,\"execution_time\":$execution_time,\"stdout\":\"$(escape_json "$stdout")\",\"stderr\":\"$(escape_json "$stderr")\"}"
}

# Escape special characters for JSON
function escape_json() {
  local text=$1
  echo "$text" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/\n/\\n/g' | sed 's/\t/\\t/g'
}

# Output in JSON format
function output_json_format() {
  local daemon_status=$1
  shift
  local script_entries=("$@")
  
  # Start JSON output
  echo "{"
  echo "  \"daemon\": {"
  echo "    \"status\": \"$daemon_status\""
  if [[ "$daemon_status" == "RUNNING" ]]; then
    echo "    ,\"pid\": $(cat "$(get_pid_file)")"
  fi
  echo "  },"
  echo "  \"scripts\": ["
  
  # Add script entries
  local first=true
  for entry in "${script_entries[@]}"; do
    if [[ "$first" == "true" ]]; then
      first=false
    else
      echo ","
    fi
    echo "    $entry"
  done
  
  # Close JSON
  echo "  ]"
  echo "}"
}

# Output in text format
function output_text_format() {
  local daemon_status=$1
  shift
  local script_entries=("$@")
  local verbose=$1
  
  # Print daemon status
  echo "Daemon: $daemon_status"
  if [[ "$daemon_status" == "RUNNING" ]]; then
    echo "PID: $(cat "$(get_pid_file)")"
  fi
  echo ""
  
  # Print script status
  if [[ ${#script_entries[@]} -eq 0 ]]; then
    echo "No scripts configured or matching filter criteria."
    return
  fi
  
  echo "Scripts:"
  printf "%-20s %-10s %-20s %-10s %-10s\n" "NAME" "STATUS" "LAST RUN" "EXIT CODE" "DURATION"
  echo "--------------------------------------------------------------------------------"
  
  for entry in "${script_entries[@]}"; do
    # Parse entry
    local name=$(echo "$entry" | jq -r '.name')
    local status=$(echo "$entry" | jq -r '.status')
    local last_run=$(echo "$entry" | jq -r '.last_run')
    local exit_code=$(echo "$entry" | jq -r '.exit_code')
    local execution_time=$(echo "$entry" | jq -r '.execution_time')
    
    printf "%-20s %-10s %-20s %-10s %-10s\n" "$name" "$status" "$last_run" "$exit_code" "${execution_time}s"
    
    # Show stdout/stderr if verbose
    if [[ "$verbose" == "true" ]]; then
      local stdout=$(echo "$entry" | jq -r '.stdout')
      local stderr=$(echo "$entry" | jq -r '.stderr')
      
      if [[ -n "$stdout" ]]; then
        echo "  STDOUT:"
        echo "    $stdout" | sed 's/^/    /'
      fi
      
      if [[ -n "$stderr" ]]; then
        echo "  STDERR:"
        echo "    $stderr" | sed 's/^/    /'
      fi
      
      echo ""
    fi
  done
}

# Get history file path from config
function get_history_file_path() {
  local history_file=$(yq e '.daemon.history_file' "$CONFIG_FILE")
  echo "${history_file/#~/$HOME}"
}

# Store execution history
function store_execution_history() {
  local script_entries=("$@")
  local history_file=$(get_history_file_path)
  local history_dir=$(dirname "$history_file")
  local retention_days=$(yq e '.daemon.history_retention_days // 30' "$CONFIG_FILE")
  
  # Create directory if it doesn't exist
  if [[ ! -d "$history_dir" ]]; then
    mkdir -p "$history_dir"
  fi
  
  # Create history file if it doesn't exist
  if [[ ! -f "$history_file" ]]; then
    echo "[]" > "$history_file"
  fi
  
  # Read existing history
  local history=$(cat "$history_file")
  
  # Add new entries
  local timestamp=$(date +%s)
  for entry in "${script_entries[@]}"; do
    # Add timestamp to entry
    entry=$(echo "$entry" | jq --arg ts "$timestamp" '. + {timestamp: $ts|tonumber}')
    
    # Add to history
    history=$(echo "$history" | jq --argjson entry "$entry" '. += [$entry]')
  done
  
  # Prune old entries
  local cutoff=$(($(date +%s) - retention_days * 86400))
  history=$(echo "$history" | jq --arg cutoff "$cutoff" '[.[] | select(.timestamp >= ($cutoff|tonumber))]')
  
  # Write back to file
  echo "$history" > "$history_file"
}

# Add configuration options to config.sh
# In src/lib/config.sh, add:
# - history_file: ~/.bamon/history.json
# - history_retention_days: 30
```

2. Update the main CLI parser in `src/bamon.sh` to support the new command-line options:
```bash
# Add to the existing options for status command:
--json)
  args[--json]=true
  ;;
```

3. Add configuration options to the default configuration template in `src/lib/config.sh`:
```bash
# Default configuration
DEFAULT_CONFIG=$(cat <<EOF
daemon:
  pid_file: ~/.bamon/bamon.pid
  log_file: ~/.bamon/bamon.log
  history_file: ~/.bamon/history.json
  history_retention_days: 30
EOF
)
```

4. Implement functions to retrieve script execution details in `src/lib/config.sh`:
```bash
# Get script last run timestamp
function get_script_last_run() {
  local script=$1
  local timestamp=$(yq e ".scripts.$script.last_run" "$CONFIG_FILE")
  
  if [[ "$timestamp" == "null" ]]; then
    echo "Never"
  else
    date -r "$timestamp" "+%Y-%m-%d %H:%M:%S"
  fi
}

# Get script last status
function get_script_last_status() {
  local script=$1
  local status=$(yq e ".scripts.$script.last_status" "$CONFIG_FILE")
  
  if [[ "$status" == "null" ]]; then
    echo "UNKNOWN"
  else
    echo "$status"
  fi
}

# Get script exit code
function get_script_exit_code() {
  local script=$1
  local exit_code=$(yq e ".scripts.$script.exit_code" "$CONFIG_FILE")
  
  if [[ "$exit_code" == "null" ]]; then
    echo "-"
  else
    echo "$exit_code"
  fi
}

# Get script execution time
function get_script_execution_time() {
  local script=$1
  local time=$(yq e ".scripts.$script.execution_time" "$CONFIG_FILE")
  
  if [[ "$time" == "null" ]]; then
    echo "-"
  else
    echo "$time"
  fi
}

# Get script stdout
function get_script_stdout() {
  local script=$1
  local stdout=$(yq e ".scripts.$script.stdout" "$CONFIG_FILE")
  
  if [[ "$stdout" == "null" ]]; then
    echo ""
  else
    echo "$stdout"
  fi
}

# Get script stderr
function get_script_stderr() {
  local script=$1
  local stderr=$(yq e ".scripts.$script.stderr" "$CONFIG_FILE")
  
  if [[ "$stderr" == "null" ]]; then
    echo ""
  else
    echo "$stderr"
  fi
}
```

5. Update the script execution function in `src/lib/daemon.sh` to store additional execution details:
```bash
# After script execution, add:
yq e -i ".scripts.$script.last_run = $(date +%s)" "$CONFIG_FILE"
yq e -i ".scripts.$script.last_status = \"$status\"" "$CONFIG_FILE"
yq e -i ".scripts.$script.exit_code = $exit_code" "$CONFIG_FILE"
yq e -i ".scripts.$script.execution_time = $execution_time" "$CONFIG_FILE"
yq e -i ".scripts.$script.stdout = \"$(escape_yaml "$stdout")\"" "$CONFIG_FILE"
yq e -i ".scripts.$script.stderr = \"$(escape_yaml "$stderr")\"" "$CONFIG_FILE"

# Add escape_yaml function
function escape_yaml() {
  local text=$1
  echo "$text" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/\n/\\n/g' | sed 's/\t/\\t/g'
}
```

6. Update the documentation to include the new status command options:
```
status [options]
  Display the current status of all configured scripts

  Options:
    --verbose         Show detailed output including stdout/stderr
    --failed-only     Show only failed scripts
    --json            Output in JSON format
```

